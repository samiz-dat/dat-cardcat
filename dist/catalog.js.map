{"version":3,"sources":["../src/catalog.js"],"names":["createCatalog","Catalog","constructor","baseDir","pathIsDownloaded","dat","filePath","existsSync","join","directory","dats","db","format","dir","base","isReady","publicDatabaseFuncs","forEach","fn","args","initDatabase","init","cleanupDatsRegistry","console","log","getDats","map","filter","each","bold","removeDat","then","discoverDats","name","opts","createIfMissing","sparse","importDat","importDatsFromDB","startsWith","key","keys","importDir","split","sep","slice","importRemoteDat","resolve","newDat","on","handleDatImportEvent","handleDatSyncMetadataEvent","run","registerDat","importFiles","listContents","file","importDatFile","catch","err","dw","datkey","toString","clearTexts","addDat","finally","e","renameDat","renameAsync","promisify","rename","newPath","pathToDat","p","updateDat","deleteDir","rimrafAsync","importedData","downloaded","downloadedStr","addText","author","author_sort","authorSort","title","checkout","warn","reject","download","scanForDownloads","Array","isArray","getDatsWith","row","uniq","getItemsWith","rows","doc","itemIsDownloaded","setDownloaded","downloadContent","dbRow","path","stat","dataDir","dataDirFinal","process","cwd","get","mkdirSync","catalog"],"mappings":";;;;;;;;AAQgC;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiQbA,a,GAAAA,a,CA1QhB,4B,2CACA,wB,uCACA,oC,mDACA,8B,6CACA,gC,+CACA,gC,+CACA,kC,+CAEA,4B,yCACA,0B,uCAEA,gDACA,8C,mJACA;AAEA;AACO,MAAMC,OAAN,CAAc,CACnBC,YAAYC,OAAZ,EAAqB,MAkOrBC,gBAlOqB,GAkOF,CAACC,GAAD,EAAMC,QAAN,KAAmB,aAAGC,UAAH,CAAc,eAAKC,IAAL,CAAUH,IAAII,SAAd,EAAyBH,QAAzB,CAAd,CAlOjB,CACnB,KAAKH,OAAL,GAAeA,OAAf,CACA,KAAKO,IAAL,GAAY,EAAZ,CACA,KAAKC,EAAL,GAAU,iBAAa,eAAKC,MAAL,CAAY,EACjCC,KAAK,KAAKV,OADuB,EAEjCW,MAAM,YAF2B,EAAZ,CAAb,CAAV,CAHmB,CAOnB;AACA;AACA,SAAKC,OAAL,GAAe,KAAf,CATmB,CAWnB;AACA;AACA,UAAMC,sBAAsB,CAAC,SAAD,EAAY,YAAZ,EAA0B,kBAA1B,EAA8C,eAA9C,EAA+D,QAA/D,EAAyE,oBAAzE,EAA+F,eAA/F,CAA5B,CACAA,oBAAoBC,OAApB,CAA6BC,EAAD,IAAQ,CAClC,IAAI,OAAO,KAAKP,EAAL,CAAQO,EAAR,CAAP,KAAuB,UAA3B,EAAuC,KAAKA,EAAL,IAAW,CAAC,GAAGC,IAAJ,KAAa,KAAKR,EAAL,CAAQO,EAAR,EAAY,GAAGC,IAAf,CAAxB,CACxC,CAFD,EAGD,CAEDC,eAAe,CACb,OAAO,KAAKT,EAAL,CAAQU,IAAR,EAAP,CACD,CAtBkB,CAwBnB;AACA;AACA;AACAC,wBAAsB,CACpBC,QAAQC,GAAR,CAAY,+BAAZ,EACA,OAAO,KAAKC,OAAL,GACJC,GADI,CACArB,OAAOA,GADP,EAEJsB,MAFI,CAEGtB,OAAO,yBAAQA,IAAIQ,GAAZ,CAFV,EAGJe,IAHI,CAGEvB,GAAD,IAAS,CACbkB,QAAQC,GAAR,CAAa,aAAY,gBAAMK,IAAN,CAAWxB,IAAIQ,GAAf,CAAoB,6BAA7C,EACA,OAAO,KAAKiB,SAAL,CAAezB,IAAIA,GAAnB,EAAwB,KAAxB,CAAP,CACD,CANI,EAOJ0B,IAPI,CAOC,MAAM,IAPP,CAAP,CAQD,CArCkB,CAuCnB;AACAC,iBAAe,CACb,OAAO,gCAAe,KAAK7B,OAApB,EACJuB,GADI,CACCO,IAAD,IAAU,CACbV,QAAQC,GAAR,CAAa,2BAA0B,gBAAMK,IAAN,CAAWI,IAAX,CAAiB,WAAxD,EACA,MAAMC,OAAO,EACXD,IADW,EAEXE,iBAAiB,KAFN,EAEa;AACxBC,gBAAQ,IAHG,EAAb,CAKA,OAAO,KAAKC,SAAL,CAAeH,IAAf,CAAP,CACD,CATI,EAUJH,IAVI,CAUC,MAAM,KAAKT,mBAAL,EAVP,EAWJS,IAXI,CAWC,MAAM,KAAKO,gBAAL,EAXP,EAYJP,IAZI,CAYC,MAAM,IAZP,CAAP,CAaD,CAtDkB,CAwDnB;AACAO,qBAAmB,CACjB,OAAO,KAAKb,OAAL,GACJC,GADI,CACArB,OAAOA,GADP,EAEJsB,MAFI,CAEGtB,OAAO,yBAAQA,IAAIQ,GAAZ,CAFV,EAE4B;AAF5B,KAGJc,MAHI,CAGGtB,OAAO,CAACA,IAAIQ,GAAJ,CAAQ0B,UAAR,CAAmB,KAAKpC,OAAxB,CAHX,EAG6C;AAH7C,KAIJwB,MAJI,CAIGtB,OAAO,EAAEA,IAAImC,GAAJ,IAAW,KAAK9B,IAAL,CAAU+B,IAAV,EAAb,CAJV,EAI0C;AAJ1C,KAKJb,IALI,CAKCvB,OAAO,KAAKqC,SAAL,CAAerC,IAAIQ,GAAnB,EAAwBR,IAAI4B,IAA5B,CALR,EAMJF,IANI,CAMC,MAAMR,QAAQC,GAAR,CAAY,uBAAZ,CANP,CAAP,CAOD,CAjEkB,CAmEnB;AACA;AACAkB,YAAUjC,SAAV,EAAqBwB,OAAO,KAA5B,EAAmC,CACjCV,QAAQC,GAAR,CAAa,yCAAwCf,SAAU,EAA/D,EACA,MAAMyB,OAAO,EACXzB,SADW,EAEXwB,MAAMA,QAAQxB,UAAUkC,KAAV,CAAgB,eAAKC,GAArB,EAA0BC,KAA1B,CAAgC,CAAC,CAAjC,EAAoC,CAApC,CAFH,EAAb,CAIA,OAAO,KAAKR,SAAL,CAAeH,IAAf,CAAP,CACD,CA5EkB,CA8EnB;AACAY,kBAAgBN,GAAhB,EAAqBP,OAAO,KAA5B,EAAmC,CACjCV,QAAQC,GAAR,CAAa,oCAAmCgB,GAAI,EAApD,EACA,MAAMN,OAAO,EACXM,GADW,EAEXP,MAAMA,QAAQO,GAFH,EAGXJ,QAAQ,IAHG,EAAb,CAKA,OAAO,KAAKC,SAAL,CAAeH,IAAf,CAAP,CACD,CAvFkB,CAyFnB;AACAG,YAAUH,IAAV,EAAgB,CACd,IAAI,SAASA,IAAT,IAAiBA,KAAKM,GAAL,IAAY,KAAK9B,IAAtC,EAA4C,CAC1C;AACAa,cAAQC,GAAR,CAAa,0DAAyDU,KAAKM,GAAI,EAA/E,EACA,OAAO,mBAAQO,OAAR,CAAgB,KAAhB,CAAP,CACD,CACD,IAAI,CAACb,KAAKzB,SAAV,EAAqB,CACnByB,KAAKzB,SAAL,GAAiB,eAAKG,MAAL,CAAY,EAC3BC,KAAK,KAAKV,OADiB,EAE3BW,MAAOoB,KAAKD,IAAN,GAAcC,KAAKD,IAAnB,GAA0BC,KAAKM,GAFV,EAAZ,CAAjB,CAID,CACD,MAAMQ,SAAS,kBAAed,IAAf,EAAqB,IAArB,CAAf,CAZc,CAad;AACAc,WAAOC,EAAP,CAAU,QAAV,EAAoB,CAAC,GAAG9B,IAAJ,KAAa,KAAK+B,oBAAL,CAA0B,GAAG/B,IAA7B,CAAjC,EACA6B,OAAOC,EAAP,CAAU,eAAV,EAA2B,CAAC,GAAG9B,IAAJ,KAAa,KAAKgC,0BAAL,CAAgC,GAAGhC,IAAnC,CAAxC,EAfc,CAgBd;AACA,WAAO6B,OAAOI,GAAP,GACJrB,IADI,CACC,MAAM,KAAKsB,WAAL,CAAiBL,MAAjB,CADP,EAEJjB,IAFI,CAEC,MAAMiB,OAAOM,WAAP,EAFP,EAGJvB,IAHI,CAGC,MAAMiB,OAAOO,YAAP,EAHP,EAIJ3B,IAJI,CAIC4B,QAAQ,KAAKC,aAAL,CAAmBT,MAAnB,EAA2BQ,IAA3B,CAJT,EAKJE,KALI,CAKGC,GAAD,IAAS,CACdpC,QAAQC,GAAR,CAAa,yCAAwCU,KAAKzB,SAAU,EAApE,EACAc,QAAQC,GAAR,CAAYmC,GAAZ,EACD,CARI,CAAP,CASD,CApHkB,CAsHnB;AACAN,cAAYO,EAAZ,EAAgB,CACd,MAAMC,SAASD,GAAGvD,GAAH,CAAOmC,GAAP,CAAWsB,QAAX,CAAoB,KAApB,CAAf,CACAvC,QAAQC,GAAR,CAAa,eAAcqC,MAAO,mBAAlC,EACA,OAAO,KAAKlD,EAAL,CAAQmB,SAAR,CAAkB+B,MAAlB,EACJ9B,IADI,CACC,MAAM,KAAKpB,EAAL,CAAQoD,UAAR,CAAmBF,MAAnB,CADP,EAEJ9B,IAFI,CAEC,MAAM,KAAKpB,EAAL,CAAQqD,MAAR,CAAeH,MAAf,EAAuBD,GAAG3B,IAA1B,EAAgC2B,GAAGnD,SAAnC,CAFP,EAGJwD,OAHI,CAGI,MAAM,CAAE,KAAKvD,IAAL,CAAUmD,MAAV,IAAoBD,EAApB,CAAyB,CAHrC,EAIJF,KAJI,CAIEQ,KAAK3C,QAAQC,GAAR,CAAY0C,CAAZ,CAJP,CAAP,CAKD,CA/HkB,CAiInB;AACAC,YAAU3B,GAAV,EAAeP,IAAf,EAAqB,CACnB,MAAMmC,cAAc,mBAAQC,SAAR,CAAkB,aAAGC,MAArB,CAApB,CACA,MAAMC,UAAU,eAAK3D,MAAL,CAAY,EAC1BC,KAAK,KAAKV,OADgB,EAE1BW,MAAMmB,IAFoB,EAAZ,CAAhB,CAIA,OAAO,KAAKtB,EAAL,CAAQ6D,SAAR,CAAkBhC,GAAlB,EACJT,IADI,CACC0C,KAAKL,YAAYK,EAAE5D,GAAd,EAAmB0D,OAAnB,CADN,EAEJxC,IAFI,CAEC,MAAM,KAAKpB,EAAL,CAAQ+D,SAAR,CAAkBlC,GAAlB,EAAuBP,IAAvB,EAA6BsC,OAA7B,CAFP,CAAP,CAGD,CA3IkB,CA6InB;AACAzC,YAAUU,GAAV,EAAemC,YAAY,IAA3B,EAAiC,CAC/B,IAAIA,SAAJ,EAAe,CACb,OAAO,KAAKhE,EAAL,CAAQ6D,SAAR,CAAkBhC,GAAlB,EACJT,IADI,CACE0C,CAAD,IAAO,CACX,IAAIA,EAAE5D,GAAF,CAAM0B,UAAN,CAAiB,KAAKpC,OAAtB,CAAJ,EAAoC,CAClC,MAAMyE,cAAc,mBAAQP,SAAR,kBAApB,CACA,OAAO,KAAK1D,EAAL,CAAQmB,SAAR,CAAkBU,GAAlB,EACJT,IADI,CACC,MAAM,KAAKpB,EAAL,CAAQoD,UAAR,CAAmBvB,GAAnB,CADP,EAEJT,IAFI,CAEC,MAAM6C,YAAYH,EAAE5D,GAAd,CAFP,CAAP,CAGD,CACD,OAAO,mBAAQkC,OAAR,CAAgB,KAAhB,CAAP,CACD,CATI,CAAP,CAUD,CACD,OAAO,KAAKpC,EAAL,CAAQmB,SAAR,CAAkBU,GAAlB,EACJT,IADI,CACC,MAAM,KAAKpB,EAAL,CAAQoD,UAAR,CAAmBvB,GAAnB,CADP,CAAP,CAED,CA7JkB,CA+JnB;AACAiB,gBAAcpD,GAAd,EAAmBmD,IAAnB,EAAyB5C,SAAS,SAAlC,EAA6C,CAC3C,MAAMiE,eAAe,yBAAWrB,IAAX,EAAiB5C,MAAjB,CAArB,CACA,IAAIiE,YAAJ,EAAkB,CAChB,MAAMC,aAAa,KAAK1E,gBAAL,CAAsBC,GAAtB,EAA2BmD,IAA3B,CAAnB,CACA,MAAMuB,gBAAiBD,UAAD,GAAe,KAAf,GAAuB,KAA7C,CACAvD,QAAQC,GAAR,CAAY,gBAAMK,IAAN,CAAW,SAAX,CAAZ,EAAmCkD,aAAnC,EAAkDvB,IAAlD,EACA,OAAO,KAAK7C,EAAL,CAAQqE,OAAR,CAAgB,EACrB3E,KAAKA,IAAImC,GADY,EAErByC,QAAQJ,aAAaI,MAFA,EAGrBC,aAAaL,aAAaM,UAHL,EAIrBC,OAAOP,aAAaO,KAJC,EAKrB5B,MAAMqB,aAAarB,IALE,EAMrBsB,UANqB,EAAhB,CAAP,CAQD,CACD,OAAO,mBAAQ/B,OAAR,CAAgB,KAAhB,CAAP,CACD,CAhLkB,CAkLnB;AACA;AACAsC,WAASnD,IAAT,EAAe,CACb,IAAI,CAACA,IAAL,EAAW,CACTX,QAAQ+D,IAAR,CAAa,qCAAb,EACA,OAAO,mBAAQC,MAAR,EAAP,CACD,CACD,IAAIrD,KAAK7B,GAAT,EAAc,CACZ,IAAI,OAAO6B,KAAK7B,GAAZ,KAAoB,QAAxB,EAAkC,CAChC,OAAO,KAAKmF,QAAL,CAActD,KAAK7B,GAAnB,EAAwB6B,IAAxB,EACJH,IADI,CACC,MAAM,KAAK0D,gBAAL,CAAsBvD,IAAtB,EAA4BA,KAAK7B,GAAjC,CADP,CAAP,CAED,CAHD,MAGO,IAAIqF,MAAMC,OAAN,CAAczD,KAAK7B,GAAnB,CAAJ,EAA6B,CAClC,OAAO,mBAAQqB,GAAR,CAAYQ,KAAK7B,GAAjB,EAAsBA,OAAO,KAAKgF,QAAL,cAAmBnD,IAAnB,IAAyB7B,GAAzB,IAA7B,CAAP,CACD,CACDkB,QAAQ+D,IAAR,CAAa,wDAAb,EACA,OAAO,mBAAQC,MAAR,EAAP,CACD,CAdY,CAeb;AACA,WAAO,KAAK5E,EAAL,CAAQiF,WAAR,CAAoB1D,IAApB,EACJR,GADI,CACAmE,OAAOA,IAAIxF,GADX,EAEJuB,IAFI,CAECvB,OAAO,KAAKmF,QAAL,CAAcnF,GAAd,EAAmB6B,IAAnB,CAFR,EAEkC;AAFlC,KAGJH,IAHI,CAGCrB,QAAQ,KAAK+E,gBAAL,CAAsBvD,IAAtB,EAA4B,iBAAE4D,IAAF,CAAOpF,IAAP,CAA5B,CAHT,CAAP,CAID,CAxMkB,CA0MnB;AACA;AACA+E,mBAAiBvD,IAAjB,EAAuB7B,GAAvB,EAA4B,CAC1B,OAAO,KAAKM,EAAL,CAAQoF,YAAR,CAAqB7D,IAArB,EAA2B7B,GAA3B,EACJ0B,IADI,CACCiE,QAAQA,KAAKrE,MAAL,CAAYsE,OAAO,KAAKC,gBAAL,CAAsBD,GAAtB,CAAnB,CADT,EAEJrE,IAFI,CAECiE,OAAO,KAAKM,aAAL,CAAmBN,IAAIxF,GAAvB,EAA4BwF,IAAIZ,MAAhC,EAAwCY,IAAIT,KAA5C,EAAmDS,IAAIrC,IAAvD,CAFR,CAAP,CAGD,CAEDgC,SAASnF,GAAT,EAAc6B,IAAd,EAAoB,CAClB,IAAIA,KAAK+C,MAAL,IAAe/C,KAAKkD,KAApB,IAA6BlD,KAAKsB,IAAtC,EAA4C,CAC1CjC,QAAQC,GAAR,CAAa,gBAAeU,KAAK+C,MAAO,IAAG/C,KAAKkD,KAAM,IAAGlD,KAAKsB,IAAK,SAAQnD,GAAI,EAA/E,EACA,OAAO,KAAKK,IAAL,CAAUL,GAAV,EAAe+F,eAAf,CAA+B,eAAK5F,IAAL,CAAU0B,KAAK+C,MAAf,EAAuB/C,KAAKkD,KAA5B,EAAmClD,KAAKsB,IAAxC,CAA/B,CAAP,CACD,CAHD,MAGO,IAAItB,KAAK+C,MAAL,IAAe/C,KAAKkD,KAAxB,EAA+B,CACpC7D,QAAQC,GAAR,CAAa,gBAAeU,KAAK+C,MAAO,IAAG/C,KAAKkD,KAAM,SAAQ/E,GAAI,EAAlE,EACA,OAAO,KAAKK,IAAL,CAAUL,GAAV,EAAe+F,eAAf,CAA+B,eAAK5F,IAAL,CAAU0B,KAAK+C,MAAf,EAAuB/C,KAAKkD,KAA5B,CAA/B,CAAP,CACD,CAHM,MAGA,IAAIlD,KAAK+C,MAAT,EAAiB,CACtB1D,QAAQC,GAAR,CAAa,gBAAeU,KAAK+C,MAAO,SAAQ5E,GAAI,EAApD,EACA,OAAO,KAAKK,IAAL,CAAUL,GAAV,EAAe+F,eAAf,CAA+B,eAAK5F,IAAL,CAAU0B,KAAK+C,MAAf,CAA/B,CAAP,CACD,CAViB,CAWlB;AACA1D,YAAQC,GAAR,CAAa,gCAA+BU,KAAK7B,GAAI,EAArD,EACA,OAAO,KAAKK,IAAL,CAAUL,GAAV,EAAe+F,eAAf,EAAP,CACD,CAhOkB,CAkOnB;AAGA;AACAF,mBAAiBG,KAAjB,EAAwB,CACtB,OAAO,KAAKjG,gBAAL,CACL,KAAKM,IAAL,CAAU2F,MAAMhG,GAAhB,CADK,EAEL,eAAKG,IAAL,CAAU6F,MAAMpB,MAAhB,EAAwBoB,MAAMjB,KAA9B,EAAqCiB,MAAM7C,IAA3C,CAFK,CAAP,CAGD,CA1OkB,CA4OnB;AACA;AACA;AACAL,6BAA2BS,EAA3B,EAA+B,CAC7BrC,QAAQC,GAAR,CAAY,iBAAZ,EACA,mBAAQE,GAAR,CAAYkC,GAAGL,YAAH,EAAZ,EAA+BC,QAAQ,KAAKC,aAAL,CAAmBG,EAAnB,EAAuBJ,IAAvB,CAAvC,EACD,CAlPkB,CAoPnB;AACAN,uBAAqBU,EAArB,EAAyB0C,IAAzB,EAA+BC,IAA/B,EAAqC,CACnC;AACD,GAvPkB,C,QAARtG,O,GAAAA,O,CA0PN,SAASD,aAAT,CAAuBwG,OAAvB,EAAgC,CACrC;AACA,MAAIC,eAAe,eAAKjG,IAAL,CAAUkG,QAAQC,GAAR,EAAV,EAAyB,iBAAOC,GAAP,CAAW,SAAX,CAAzB,CAAnB,CACAH,eAAeD,WAAWC,YAA1B,CAHqC,CAKrC;AACA,MAAI,CAAC,aAAGlG,UAAH,CAAckG,YAAd,CAAL,EAAkC,CAChC,aAAGI,SAAH,CAAaJ,YAAb,EACD,CAED,MAAMK,UAAU,IAAI7G,OAAJ,CAAYwG,YAAZ,CAAhB,CACA,OAAOK,QAAQ1F,YAAR,GAAuBW,IAAvB,CAA4B,MAAM+E,OAAlC,CAAP,CACD,C,kBAEc7G,O","file":"catalog.js","sourcesContent":["import path from 'path';\nimport fs from 'fs';\nimport Promise from 'bluebird';\nimport chalk from 'chalk';\nimport _ from 'lodash';\nimport rimraf from 'rimraf';\nimport config from './config';\n\nimport DatWrapper from './dat'; // this function can be made a method of dat class too.\nimport Database from './db'; // eslint-disable-line\n\nimport { getDirectories, notADir } from './utils/filesystem';\nimport parseEntry from './utils/importers';\n// @todo: this.db.close(); should be called on shutdown\n\n// Class definition\nexport class Catalog {\n  constructor(baseDir) {\n    this.baseDir = baseDir;\n    this.dats = [];\n    this.db = new Database(path.format({\n      dir: this.baseDir,\n      base: 'catalog.db',\n    }));\n    // If you ever need to see what queries are being run uncomment the following.\n    // this.db.on('query', queryData => console.log(queryData));\n    this.isReady = false;\n\n    // Now, database functions are passed on from this.db\n    // explicitly declare publicly accessible database functions\n    const publicDatabaseFuncs = ['getDats', 'getAuthors', 'getAuthorLetters', 'getTitlesWith', 'search', 'getTitlesForAuthor', 'setDownloaded'];\n    publicDatabaseFuncs.forEach((fn) => {\n      if (typeof this.db[fn] === 'function') this[fn] = (...args) => this.db[fn](...args);\n    });\n  }\n\n  initDatabase() {\n    return this.db.init();\n  }\n\n  // Every imported and added dat gets added to the `dats` table of the database. If\n  // the directories are deleted then these db entries are useless and should be removed.\n  // This will simply confirm that every dat directory in the db still exists.\n  cleanupDatsRegistry() {\n    console.log('Cleaning up the dats registry');\n    return this.getDats()\n      .map(dat => dat)\n      .filter(dat => notADir(dat.dir))\n      .each((dat) => {\n        console.log(`Removing: ${chalk.bold(dat.dir)} (directory does not exist)`);\n        return this.removeDat(dat.dat, false);\n      })\n      .then(() => this);\n  }\n\n  // Look inside the base directory for any directories that seem to be dats\n  discoverDats() {\n    return getDirectories(this.baseDir)\n      .map((name) => {\n        console.log(`Attempting to load dir: ${chalk.bold(name)} as a dat`);\n        const opts = {\n          name,\n          createIfMissing: false, // @todo: this was false before, but threw error. find out why?\n          sparse: true,\n        };\n        return this.importDat(opts);\n      })\n      .then(() => this.cleanupDatsRegistry())\n      .then(() => this.importDatsFromDB())\n      .then(() => this);\n  }\n\n  // Imports dats listed in the dats table of the database\n  importDatsFromDB() {\n    return this.getDats()\n      .map(dat => dat)\n      .filter(dat => notADir(dat.dir)) // directory exists\n      .filter(dat => !dat.dir.startsWith(this.baseDir)) // not in data directory\n      .filter(dat => !(dat.key in this.dats.keys())) // not in registry\n      .each(dat => this.importDir(dat.dir, dat.name))\n      .then(() => console.log('Imported dats from DB'));\n  }\n\n  // Imports a directory on the local filesystem as a dat.\n  // This should not be called on any directories inside `dataDir`, which are loaded differently\n  importDir(directory, name = false) {\n    console.log(`Attempting to import local directory: ${directory}`);\n    const opts = {\n      directory,\n      name: name || directory.split(path.sep).slice(-1)[0],\n    };\n    return this.importDat(opts);\n  }\n\n  // Importing a remote dat by its key\n  importRemoteDat(key, name = false) {\n    console.log(`Attempting to import remote dat: ${key}`);\n    const opts = {\n      key,\n      name: name || key,\n      sparse: true,\n    };\n    return this.importDat(opts);\n  }\n\n  // Does the work of importing a functional dat into the catalog\n  importDat(opts) {\n    if ('key' in opts && opts.key in this.dats) {\n      // The dat is already loaded, we shouldn't reimport it\n      console.log(`You are trying to import a dat that is already loaded: ${opts.key}`);\n      return Promise.resolve(false);\n    }\n    if (!opts.directory) {\n      opts.directory = path.format({\n        dir: this.baseDir,\n        base: (opts.name) ? opts.name : opts.key,\n      });\n    }\n    const newDat = new DatWrapper(opts, this);\n    // listen to events emitted from this dat wrapper\n    newDat.on('import', (...args) => this.handleDatImportEvent(...args));\n    newDat.on('sync metadata', (...args) => this.handleDatSyncMetadataEvent(...args));\n    // dw.on('download', (...args) => this.handleDatDownloadEvent(...args));\n    return newDat.run()\n      .then(() => this.registerDat(newDat))\n      .then(() => newDat.importFiles())\n      .then(() => newDat.listContents())\n      .each(file => this.importDatFile(newDat, file))\n      .catch((err) => {\n        console.log(`* Something went wrong when importing ${opts.directory}`);\n        console.log(err);\n      });\n  }\n\n  // Registers dat in catalog array and in database (@todo)\n  registerDat(dw) {\n    const datkey = dw.dat.key.toString('hex');\n    console.log(`Adding dat (${datkey}) to the catalog.`);\n    return this.db.removeDat(datkey)\n      .then(() => this.db.clearTexts(datkey))\n      .then(() => this.db.addDat(datkey, dw.name, dw.directory))\n      .finally(() => { this.dats[datkey] = dw; })\n      .catch(e => console.log(e));\n  }\n\n  // Rename a dat - updates database and directory\n  renameDat(key, name) {\n    const renameAsync = Promise.promisify(fs.rename);\n    const newPath = path.format({\n      dir: this.baseDir,\n      base: name,\n    });\n    return this.db.pathToDat(key)\n      .then(p => renameAsync(p.dir, newPath))\n      .then(() => this.db.updateDat(key, name, newPath));\n  }\n\n  // Delete a dat from catalog. Only deletes directory if it's in the baseDir\n  removeDat(key, deleteDir = true) {\n    if (deleteDir) {\n      return this.db.pathToDat(key)\n        .then((p) => {\n          if (p.dir.startsWith(this.baseDir)) {\n            const rimrafAsync = Promise.promisify(rimraf);\n            return this.db.removeDat(key)\n              .then(() => this.db.clearTexts(key))\n              .then(() => rimrafAsync(p.dir));\n          }\n          return Promise.resolve(false);\n        });\n    }\n    return this.db.removeDat(key)\n      .then(() => this.db.clearTexts(key));\n  }\n\n  // Adds an entry from a Dat\n  importDatFile(dat, file, format = 'calibre') {\n    const importedData = parseEntry(file, format);\n    if (importedData) {\n      const downloaded = this.pathIsDownloaded(dat, file);\n      const downloadedStr = (downloaded) ? '[*]' : '[ ]';\n      console.log(chalk.bold('adding:'), downloadedStr, file);\n      return this.db.addText({\n        dat: dat.key,\n        author: importedData.author,\n        author_sort: importedData.authorSort,\n        title: importedData.title,\n        file: importedData.file,\n        downloaded,\n      });\n    }\n    return Promise.resolve(false);\n  }\n\n  // Public call for syncing files within a dat\n  // opts can include {dat:, author: , title:, file: }\n  checkout(opts) {\n    if (!opts) {\n      console.warn('attempted to checkout without opts.');\n      return Promise.reject();\n    }\n    if (opts.dat) {\n      if (typeof opts.dat === 'string') {\n        return this.download(opts.dat, opts)\n          .then(() => this.scanForDownloads(opts, opts.dat));\n      } else if (Array.isArray(opts.dat)) {\n        return Promise.map(opts.dat, dat => this.checkout({ ...opts, dat }));\n      }\n      console.warn('dat option passed to check is not an array or a string');\n      return Promise.reject();\n    }\n    // With no dat provided, we must query for it\n    return this.db.getDatsWith(opts)\n      .map(row => row.dat)\n      .each(dat => this.download(dat, opts)) // .each() passes through the original array\n      .then(dats => this.scanForDownloads(opts, _.uniq(dats)));\n  }\n\n  // Checks whether a group of catalogue items have been downloaded\n  // and if so, then updates the downloaded column in the texts table\n  scanForDownloads(opts, dat) {\n    return this.db.getItemsWith(opts, dat)\n      .then(rows => rows.filter(doc => this.itemIsDownloaded(doc)))\n      .each(row => this.setDownloaded(row.dat, row.author, row.title, row.file));\n  }\n\n  download(dat, opts) {\n    if (opts.author && opts.title && opts.file) {\n      console.log(`checking out ${opts.author}/${opts.title}/${opts.file} from ${dat}`);\n      return this.dats[dat].downloadContent(path.join(opts.author, opts.title, opts.file));\n    } else if (opts.author && opts.title) {\n      console.log(`checking out ${opts.author}/${opts.title} from ${dat}`);\n      return this.dats[dat].downloadContent(path.join(opts.author, opts.title));\n    } else if (opts.author) {\n      console.log(`checking out ${opts.author} from ${dat}`);\n      return this.dats[dat].downloadContent(path.join(opts.author));\n    }\n    // If no opts are provided, but a dat is then download the whole dat\n    console.log(`checking out everything from ${opts.dat}`);\n    return this.dats[dat].downloadContent();\n  }\n\n  // Synchronous\n  pathIsDownloaded = (dat, filePath) => fs.existsSync(path.join(dat.directory, filePath));\n\n  // Given a row from the texts table, check if it has been downloaded\n  itemIsDownloaded(dbRow) {\n    return this.pathIsDownloaded(\n      this.dats[dbRow.dat],\n      path.join(dbRow.author, dbRow.title, dbRow.file));\n  }\n\n  // Event listening\n  //\n  // When a dat's metadata is synced\n  handleDatSyncMetadataEvent(dw) {\n    console.log('metadata synced');\n    Promise.map(dw.listContents(), file => this.importDatFile(dw, file));\n  }\n\n  // When a dat imports a file\n  handleDatImportEvent(dw, path, stat) {\n    // console.log('Importing: ', path);\n  }\n}\n\nexport function createCatalog(dataDir) {\n  // Directory to store all the data in\n  let dataDirFinal = path.join(process.cwd(), config.get('dataDir'));\n  dataDirFinal = dataDir || dataDirFinal;\n\n  // Create data directory if it doesn't exist yet\n  if (!fs.existsSync(dataDirFinal)) {\n    fs.mkdirSync(dataDirFinal);\n  }\n\n  const catalog = new Catalog(dataDirFinal);\n  return catalog.initDatabase().then(() => catalog);\n}\n\nexport default Catalog;\n"]}