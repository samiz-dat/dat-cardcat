{"version":3,"sources":["../src/catalog.js"],"names":["createCatalog","Catalog","constructor","baseDir","getDats","db","getAuthors","args","getAuthorLetters","getTitlesWith","search","pathIsDownloaded","dat","filePath","existsSync","join","directory","dats","format","dir","base","isReady","initDatabase","init","cleanupDatsRegistry","console","log","map","filter","each","bold","removeDat","then","discoverDats","name","opts","createIfMissing","sparse","importDat","importDatsFromDB","startsWith","key","keys","importDir","split","sep","slice","importRemoteDat","resolve","newDat","on","handleDatImportEvent","run","registerDat","importFiles","listContents","file","importDatFile","catch","err","dw","datkey","toString","clearTexts","addDat","finally","e","renameDat","renameAsync","promisify","rename","newPath","pathToDat","p","updateDat","deleteDir","rimrafAsync","importedData","downloaded","downloadedStr","addText","author","author_sort","authorSort","title","checkout","warn","reject","download","scanForDownloads","Array","isArray","getDatsWith","row","uniq","getItemsWith","rows","doc","itemIsDownloaded","setDownloaded","downloadContent","dbRow","path","stat","dataDir","dataDirFinal","process","cwd","get","mkdirSync","catalog"],"mappings":"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","file":"catalog.js","sourcesContent":["import path from 'path';\nimport fs from 'fs';\nimport Promise from 'bluebird';\nimport chalk from 'chalk';\nimport _ from 'lodash';\nimport rimraf from 'rimraf';\nimport config from './config';\n\nimport DatWrapper from './dat'; // this function can be made a method of dat class too.\nimport Database from './db';\n// import { opf2js } from './opf';\nimport { getDirectories, notADir } from './utils/filesystem';\nimport parseEntry from './utils/importers';\n// @todo: this.db.close(); should be called on shutdown\n\n// Class definition\nexport class Catalog {\n  constructor(baseDir) {\n    this.baseDir = baseDir;\n    this.dats = [];\n    this.db = new Database(path.format({\n      dir: this.baseDir,\n      base: 'catalog.db',\n    }));\n    // If you ever need to see what queries are being run uncomment the following.\n    // this.db.on('query', queryData => console.log(queryData));\n    this.isReady = false;\n  }\n\n  initDatabase() {\n    return this.db.init();\n  }\n\n  // Every imported and added dat gets added to the `dats` table of the database. If\n  // the directories are deleted then these db entries are useless and should be removed.\n  // This will simply confirm that every dat directory in the db still exists.\n  cleanupDatsRegistry() {\n    console.log('Cleaning up the dats registry');\n    return this.getDats()\n      .map(dat => dat)\n      .filter(dat => notADir(dat.dir))\n      .each((dat) => {\n        console.log(`Removing: ${chalk.bold(dat.dir)} (directory does not exist)`);\n        return this.removeDat(dat.dat, false);\n      })\n      .then(() => this);\n  }\n\n  // Look inside the base directory for any directories that seem to be dats\n  discoverDats() {\n    return getDirectories(this.baseDir)\n      .map((name) => {\n        console.log(`Attempting to load dir: ${chalk.bold(name)} as a dat`);\n        const opts = {\n          name,\n          createIfMissing: false,\n          sparse: true,\n        };\n        return this.importDat(opts);\n      })\n      .then(() => this.cleanupDatsRegistry())\n      .then(() => this.importDatsFromDB())\n      .then(() => this);\n  }\n\n  // Imports dats listed in the dats table of the database\n  importDatsFromDB() {\n    return this.getDats()\n      .map(dat => dat)\n      .filter(dat => notADir(dat.dir)) // directory exists\n      .filter(dat => !dat.dir.startsWith(this.baseDir)) // not in data directory\n      .filter(dat => !(dat.key in this.dats.keys())) // not in registry\n      .each(dat => this.importDir(dat.dir, dat.name))\n      .then(() => console.log('Imported dats from DB'));\n  }\n\n  // Imports a directory on the local filesystem as a dat.\n  // This should not be called on any directories inside `dataDir`, which are loaded differently\n  importDir(directory, name = false) {\n    console.log(`Attempting to import local directory: ${directory}`);\n    const opts = {\n      directory,\n      name: name || directory.split(path.sep).slice(-1)[0],\n    };\n    return this.importDat(opts);\n  }\n\n  // Importing a remote dat by its key\n  importRemoteDat(key, name = false) {\n    console.log(`Attempting to import remote dat: ${key}`);\n    const opts = {\n      key,\n      name: name || key,\n      sparse: true,\n    };\n    return this.importDat(opts);\n  }\n\n  // Does the work of importing a functional dat into the catalog\n  importDat(opts) {\n    if ('key' in opts && opts.key in this.dats) {\n      // The dat is already loaded, we shouldn't reimport it\n      console.log(`You are trying to import a dat that is already loaded: ${opts.key}`);\n      return Promise.resolve(false);\n    }\n    if (!opts.directory) {\n      opts.directory = path.format({\n        dir: this.baseDir,\n        base: (opts.name) ? opts.name : opts.key,\n      });\n    }\n    const newDat = new DatWrapper(opts, this);\n    // listen to events emitted from this dat wrapper\n    newDat.on('import', (...args) => this.handleDatImportEvent(...args));\n    // dw.on('download', (...args) => this.handleDatDownloadEvent(...args));\n    return newDat.run()\n      .then(() => this.registerDat(newDat))\n      .then(() => newDat.importFiles())\n      .then(() => newDat.listContents())\n      .each(file => this.importDatFile(newDat, file))\n      .catch((err) => {\n        console.log(`* Something went wrong when importing ${opts.directory}`);\n        console.log(err);\n      });\n  }\n\n  // Registers dat in catalog array and in database (@todo)\n  registerDat(dw) {\n    const datkey = dw.dat.key.toString('hex');\n    console.log(`Adding dat (${datkey}) to the catalog.`);\n    return this.db.removeDat(datkey)\n      .then(() => this.db.clearTexts(datkey))\n      .then(() => this.db.addDat(datkey, dw.name, dw.directory))\n      .finally(() => { this.dats[datkey] = dw; })\n      .catch(e => console.log(e));\n  }\n\n  // Rename a dat - updates database and directory\n  renameDat(key, name) {\n    const renameAsync = Promise.promisify(fs.rename);\n    const newPath = path.format({\n      dir: this.baseDir,\n      base: name,\n    });\n    return this.db.pathToDat(key)\n      .then(p => renameAsync(p.dir, newPath))\n      .then(() => this.db.updateDat(key, name, newPath));\n  }\n\n  // Delete a dat from catalog. Only deletes directory if it's in the baseDir\n  removeDat(key, deleteDir = true) {\n    if (deleteDir) {\n      return this.db.pathToDat(key)\n        .then((p) => {\n          if (p.dir.startsWith(this.baseDir)) {\n            const rimrafAsync = Promise.promisify(rimraf);\n            return this.db.removeDat(key)\n              .then(() => this.db.clearTexts(key))\n              .then(() => rimrafAsync(p.dir));\n          }\n          return Promise.resolve(false);\n        });\n    }\n    return this.db.removeDat(key)\n      .then(() => this.db.clearTexts(key));\n  }\n\n  // Adds an entry from a Dat\n  importDatFile(dat, file, format = 'calibre') {\n    const importedData = parseEntry(file, format);\n    if (importedData) {\n      const downloaded = this.pathIsDownloaded(dat, file);\n      const downloadedStr = (downloaded) ? '[*]' : '[ ]';\n      console.log(chalk.bold('adding:'), downloadedStr, file);\n      return this.db.addText({\n        dat: dat.key,\n        author: importedData.author,\n        author_sort: importedData.authorSort,\n        title: importedData.title,\n        file: importedData.file,\n        downloaded,\n      });\n    }\n    return Promise.resolve(false);\n  }\n\n  // Now, database functions are passed on from this.db\n  // It kind of amounts to a data API\n  getDats = () => this.db.getDats();\n  getAuthors = (...args) => this.db.getAuthors(...args);\n  getAuthorLetters = (...args) => this.db.getAuthorLetters(...args);\n  getTitlesWith = (...args) => this.db.getTitlesWith(...args);\n  search = (...args) => this.db.search(...args);\n\n  // Public call for syncing files within a dat\n  // opts can include {dat:, author: , title:, file: }\n  checkout(opts) {\n    if (!opts) {\n      console.warn('attempted to checkout without opts.');\n      return Promise.reject();\n    }\n    if (opts.dat) {\n      if (typeof opts.dat === 'string') {\n        return this.download(opts.dat, opts)\n          .then(() => this.scanForDownloads(opts, opts.dat));\n      } else if (Array.isArray(opts.dat)) {\n        return Promise.map(opts.dat, dat => this.checkout({ ...opts, dat }));\n      }\n      console.warn('dat option passed to check is not an array or a string');\n      return Promise.reject();\n    }\n    // With no dat provided, we must query for it\n    return this.db.getDatsWith(opts)\n      .map(row => row.dat)\n      .each(dat => this.download(dat, opts)) // .each() passes through the original array\n      .then(dats => this.scanForDownloads(opts, _.uniq(dats)));\n  }\n\n  // Checks whether a group of catalogue items have been downloaded\n  // and if so, then updates the downloaded column in the texts table\n  scanForDownloads(opts, dat) {\n    return this.db.getItemsWith(opts, dat)\n      .then(rows => rows.filter(doc => this.itemIsDownloaded(doc)))\n      .each(row => this.setDownloaded(row.dat, row.author, row.title, row.file));\n  }\n\n  download(dat, opts) {\n    if (opts.author && opts.title && opts.file) {\n      console.log(`checking out ${opts.author}/${opts.title}/${opts.file} from ${dat}`);\n      return this.dats[dat].downloadContent(path.join(opts.author, opts.title, opts.file));\n    } else if (opts.author && opts.title) {\n      console.log(`checking out ${opts.author}/${opts.title} from ${dat}`);\n      return this.dats[dat].downloadContent(path.join(opts.author, opts.title));\n    } else if (opts.author) {\n      console.log(`checking out ${opts.author} from ${dat}`);\n      return this.dats[dat].downloadContent(path.join(opts.author));\n    }\n    // If no opts are provided, but a dat is then download the whole dat\n    console.log(`checking out everything from ${opts.dat}`);\n    return this.dats[dat].downloadContent();\n  }\n\n  // Synchronous\n  pathIsDownloaded = (dat, filePath) => fs.existsSync(path.join(dat.directory, filePath));\n\n  // Given a row from the texts table, check if it has been downloaded\n  itemIsDownloaded(dbRow) {\n    return this.pathIsDownloaded(\n      this.dats[dbRow.dat],\n      path.join(dbRow.author, dbRow.title, dbRow.file));\n  }\n\n  // Event listening\n  //\n  // When a dat imports a file\n  handleDatImportEvent(dw, path, stat) {\n    // console.log('Importing: ', path);\n  }\n}\n\nexport function createCatalog(dataDir) {\n  // Directory to store all the data in\n  let dataDirFinal = path.join(process.cwd(), config.get('dataDir'));\n  dataDirFinal = dataDir || dataDirFinal;\n\n  // Create data directory if it doesn't exist yet\n  if (!fs.existsSync(dataDirFinal)) {\n    fs.mkdirSync(dataDirFinal);\n  }\n\n  const catalog = new Catalog(dataDirFinal);\n  return catalog.initDatabase().then(() => catalog);\n}\n\nexport default Catalog;\n"]}