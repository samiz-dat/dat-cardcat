{"version":3,"sources":["../src/catalog.js"],"names":["createCatalog","rimrafAsync","promisify","Catalog","constructor","baseDir","attachEventListenersAndJoinNetwork","dat","on","handleDatImportEvent","handleDatDownloadMetadataEvent","handleDatSyncMetadataEvent","run","ingestDatFile","data","attempts","entry","file","downloaded","multidat","getDat","key","hasFile","downloadedStr","text","state","type","version","db","addTextFromMetadata","then","emit","progress","console","log","toFixed","catch","e","delay","error","resolve","handleDatListingEvent","handleDatListingEndEvent","handleDatSyncCollectionsEvent","dw","name","ingestDatCollections","dats","format","dir","base","isReady","importQueue","queuing","queueBatchSize","parseInt","get","publicDatabaseFuncs","forEach","fn","args","warn","publicMultidatFuncs","init","databaseOnlyMode","initDatabase","initMultidat","err","close","getDats","initOthers","cleanupDatRegistry","each","registerDat","importDir","importDat","importRemoteDat","forkDat","checkout","opts","reject","collection","getTitlesWith","rows","row","download","scanForDownloads","Array","isArray","map","getDatsWith","uniq","renameDat","newPath","rename","updateDat","removeDat","deleteDir","promise","directory","pathToDat","startsWith","clearTexts","filter","bold","addDat","ingestDatContents","metadataComplete","lastImportedVersion","onEachMetadata","clearCollections","listFlattenedCollections","item","ingestDatCollectedFile","collectionArr","importedData","join","addCollectedText","author","title","resource","downloadFromDat","getItemsWith","doc","itemIsDownloaded","setDownloaded","dbRow","datHasFile","dataDir","dataDirFinal","process","cwd","existsSync","mkdirSync","catalog"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqZgBA,a,GAAAA,a,CArZhB,gC,+CACA,4B,2CACA,wB,uCACA,oC,mDACA,8B,6CACA,gC,+CACA,gC,+CACA,kC,+CAEA,0B,uCACA,sC,mDAEA,8C,0lBAN6B;AAGA;AAI7B;AAEA,MAAMC,cAAc,mBAAQC,SAAR,kBAApB,C,CAEA;AACO,MAAMC,OAAN,0BAAmC,CACxCC,YAAYC,OAAZ,EAAqB,WACnB,gBADmB,KA6LrBC,kCA7LqB,GA6LiBC,GAAD,IAAS,CAC5CA,IAAIC,EAAJ,CAAO,QAAP,EAAiB,KAAKC,oBAAtB,EACAF,IAAIC,EAAJ,CAAO,mBAAP,EAA4B,KAAKE,8BAAjC,EACAH,IAAIC,EAAJ,CAAO,eAAP,EAAwB,KAAKG,0BAA7B,EAH4C,CAI5C;AACA,aAAOJ,IAAIK,GAAJ,EAAP,CACD,CAnMoB,MAuOrBC,aAvOqB,wCAuOL,WAAOC,IAAP,EAAaC,WAAW,EAAxB,EAA+B,CAC7C;AACA,cAAMC,QAAQ,yBAAWF,KAAKG,IAAhB,EAAsB,SAAtB,CAAd,CACA,IAAID,KAAJ,EAAW,CACT,MAAME,aAAa,MAAM,MAAKC,QAAL,CAAcC,MAAd,CAAqBN,KAAKO,GAA1B,EAA+BC,OAA/B,CAAuCR,KAAKG,IAA5C,CAAzB,CACA,MAAMM,gBAAiBL,UAAD,GAAe,KAAf,GAAuB,KAA7C,CAFS,CAGT;AACA,gBAAMM,kBACJjB,KAAKO,KAAKO,GADN,EAEJI,OAAOX,KAAKY,IAAL,KAAc,KAFjB,EAGJC,SAASb,KAAKa,OAHV,IAIDX,KAJC,IAKJE,UALI,GAAN,CAOA,OAAO,MAAKU,EAAL,CAAQC,mBAAR,CAA4BL,IAA5B,EACJM,IADI,CACC,oBAAM,MAAKC,IAAL,CAAU,QAAV,eAAyBP,IAAzB,IAA+BQ,UAAUlB,KAAKkB,QAA9C,IAAN,EADD,EAEJF,IAFI,CAEC,YAAM,CACVG,QAAQC,GAAR,CAAa,GAAEpB,KAAKkB,QAAL,CAAcG,OAAd,CAAsB,CAAtB,CAAyB,GAAxC,EAA4C,SAA5C,EAAuDZ,aAAvD,EAAsET,KAAKG,IAA3E,EACD,CAJI,EAKJmB,KALI,CAKE,UAACC,CAAD,EAAO,CACZ,IAAItB,WAAW,CAAf,EAAkB,CAChBkB,QAAQC,GAAR,CAAY,OAAZ,EAAqBnB,QAArB,EACA,OAAO,mBAAQuB,KAAR,CAAc,IAAd,EAAoBR,IAApB,CAAyB,oBAAM,MAAKjB,aAAL,CAAmBC,IAAnB,EAAyBC,WAAW,CAApC,CAAN,EAAzB,CAAP,CACD,CACDkB,QAAQM,KAAR,CAAc,UAAd,EAA0BF,CAA1B,EACA,OAAO,IAAP,CACD,CAZI,CAAP,CAaD,CACD,OAAO,mBAAQG,OAAR,CAAgB,KAAhB,CAAP,CACD,CApQoB,uEAgUrB/B,oBAhUqB,GAgUGK,IAAD,IAAU,CAC/BmB,QAAQC,GAAR,CAAa,GAAEpB,KAAKkB,QAAL,CAAcG,OAAd,CAAsB,CAAtB,CAAyB,GAAxC,EAA4C,wBAA5C,EAAsErB,KAAKY,IAA3E,EAAiF,GAAjF,EAAsFZ,KAAKG,IAA3F,EACA,MAAMD,QAAQ,yBAAWF,KAAKG,IAAhB,EAAsB,SAAtB,CAAd,CACA,IAAID,KAAJ,EAAW,CACT,MAAMQ,kBACJjB,KAAKO,KAAKO,GADN,EAEJI,OAAOX,KAAKY,IAAL,KAAc,KAFjB,EAGJC,SAASb,KAAKa,OAHV,IAIDX,KAJC,IAKJE,YAAY,IALR,CAKc;AALd,UAAN,CADS,CAQT;AACA;AACA;AACA,aAAKU,EAAL,CAAQC,mBAAR,CAA4BL,IAA5B,EACGM,IADH,CACQ,MAAM,KAAKC,IAAL,CAAU,QAAV,eAAyBP,IAAzB,IAA+BQ,UAAUlB,KAAKkB,QAA9C,IADd,EAEGI,KAFH,CAESH,QAAQM,KAFjB,EAGD,CAdD,MAcO,CACLN,QAAQC,GAAR,CAAa,iBAAgBpB,KAAKG,IAAK,+BAAvC,EACD,CACF,CApVoB,MAuVrBP,8BAvVqB,GAuVaI,IAAD,IAAU,CACzC;AACAmB,cAAQC,GAAR,CAAa,GAAEpB,KAAKkB,QAAL,CAAcG,OAAd,CAAsB,CAAtB,CAAyB,GAAxC,EAA4C,0BAA5C,EAAwErB,KAAKY,IAA7E,EAAmF,GAAnF,EAAwFZ,KAAKG,IAA7F,EACA,MAAMD,QAAQ,yBAAWF,KAAKG,IAAhB,EAAsB,SAAtB,CAAd,CACA,IAAID,KAAJ,EAAW,CACT,MAAMQ,kBACJjB,KAAKO,KAAKO,GADN,EAEJI,OAAOX,KAAKY,IAAL,KAAc,KAFjB,EAGJC,SAASb,KAAKa,OAHV,IAIDX,KAJC,IAKJE,YAAY,KALR,CAKe;AALf,UAAN,CADS,CAQT;AACA;AACA;AACA,aAAKU,EAAL,CAAQC,mBAAR,CAA4BL,IAA5B,EACGM,IADH,CACQ,MAAM,KAAKC,IAAL,CAAU,QAAV,eAAyBP,IAAzB,IAA+BQ,UAAUlB,KAAKkB,QAA9C,IADd,EAEGI,KAFH,CAESH,QAAQM,KAFjB,EAGD,CAdD,MAcO,CACLN,QAAQC,GAAR,CAAa,iBAAgBpB,KAAKG,IAAK,+BAAvC,EACD,CACF,CA5WoB,MA8WrBN,0BA9WqB,GA8WSJ,GAAD,IAAS,CACpC0B,QAAQC,GAAR,CAAY,8CAAZ,EAA4D3B,GAA5D,EACD,CAhXoB,MAmXrBkC,qBAnXqB,GAmXI3B,IAAD,IAAU,CAChCmB,QAAQC,GAAR,CAAY,aAAZ,EAA2BpB,IAA3B,EACD,CArXoB,MAwXrB4B,wBAxXqB,GAwXO5B,IAAD,IAAU,CACnCmB,QAAQC,GAAR,CAAYpB,IAAZ,EACD,CA1XoB,MA4XrB6B,6BA5XqB,GA4XYC,EAAD,IAAQ,CACtCX,QAAQC,GAAR,CAAY,oDAAZ,EAAkEU,GAAGC,IAArE,EACA,KAAKC,oBAAL,CAA0BF,EAA1B,EACD,CA/XoB,CAEnB,KAAKvC,OAAL,GAAeA,OAAf,CACA,KAAK0C,IAAL,GAAY,EAAZ,CACA,KAAKnB,EAAL,GAAU,iBAAa,eAAKoB,MAAL,CAAY,EACjCC,KAAK,KAAK5C,OADuB,EAEjC6C,MAAM,YAF2B,EAAZ,CAAb,CAAV,CAIA,KAAK/B,QAAL,GAAgB,uBAAad,OAAb,CAAhB,CACA,KAAK8C,OAAL,GAAe,KAAf,CATmB,CAWnB;AACA,SAAKC,WAAL,GAAmB,EAAnB,CACA,KAAKC,OAAL,GAAe,EAAf,CACA,KAAKC,cAAL,GAAsBC,SAAS,iBAAOC,GAAP,CAAW,gBAAX,CAAT,EAAuC,EAAvC,CAAtB,CAdmB,CAgBnB;AACA;AACA,UAAMC,sBAAsB,CAC1B,SAD0B,EAE1B,YAF0B,EAG1B,sBAH0B,EAI1B,kBAJ0B,EAK1B,gBAL0B,EAM1B,eAN0B,EAO1B,QAP0B,EAQ1B,oBAR0B,EAS1B,eAT0B,CAA5B,CAYAA,oBAAoBC,OAApB,CAA6BC,EAAD,IAAQ,CAClC,IAAI,OAAO,KAAK/B,EAAL,CAAQ+B,EAAR,CAAP,KAAuB,UAA3B,EAAuC,KAAKA,EAAL,IAAW,CAAC,GAAGC,IAAJ,KAAa,KAAKhC,EAAL,CAAQ+B,EAAR,EAAY,GAAGC,IAAf,CAAxB,CAAvC,KACK3B,QAAQ4B,IAAR,CAAc,sBAAqBF,EAAG,+DAAtC,EACN,CAHD,EAKA,MAAMG,sBAAsB,CAAC,kBAAD,CAA5B,CAEAA,oBAAoBJ,OAApB,CAA6BC,EAAD,IAAQ,CAClC,IAAI,OAAO,KAAKxC,QAAL,CAAcwC,EAAd,CAAP,KAA6B,UAAjC,EAA6C,KAAKA,EAAL,IAAW,CAAC,GAAGC,IAAJ,KAAa,KAAKzC,QAAL,CAAcwC,EAAd,EAAkB,GAAGC,IAArB,CAAxB,CAA7C,KACK3B,QAAQ4B,IAAR,CAAc,sBAAqBF,EAAG,+DAAtC,EACN,CAHD,EAID,CAEDI,KAAKC,gBAAL,EAAuB,CACrB,IAAIA,gBAAJ,EAAsB,CACpB,OAAO,KAAKC,YAAL,GAAoBnC,IAApB,CAAyB,MAAM,IAA/B,CAAP,CACD,CACD,OAAO,KAAKmC,YAAL,GACJnC,IADI,CACC,MAAM,KAAKoC,YAAL,EADP,EAEJpC,IAFI,CAEC,MAAM,CACV,KAAKC,IAAL,CAAU,OAAV,EACD,CAJI,EAKJK,KALI,CAKE+B,OAAO,KAAKpC,IAAL,CAAU,OAAV,EAAmBoC,GAAnB,CALT,EAMJrC,IANI,CAMC,MAAM,IANP,CAAP,CAOD,CAEDsC,QAAQ,CACN;AACA,WAAO,KAAKjD,QAAL,CAAciD,KAAd,GACJtC,IADI,CACC,MAAM,KAAKC,IAAL,CAAU,QAAV,CADP,EAEJK,KAFI,CAEE+B,OAAO,KAAKpC,IAAL,CAAU,OAAV,EAAmBoC,GAAnB,CAFT,CAAP,CAGD,CAEDF,eAAe,CACb,OAAO,KAAKrC,EAAL,CAAQmC,IAAR,EAAP,CACD,CAEDG,eAAe,CACb,OAAO,KAAK/C,QAAL,CAAc4C,IAAd,GACJjC,IADI,CACC,MAAM,KAAKuC,OAAL,EADP,EAEJvC,IAFI,CAECiB,QAAQ,KAAK5B,QAAL,CAAcmD,UAAd,CAAyBvB,IAAzB,CAFT,EAGJjB,IAHI,CAGC,MAAM,KAAKyC,kBAAL,EAHP,EAIJzC,IAJI,CAIC,MAAM,KAAKX,QAAL,CAAckD,OAAd,EAJP,EAKJG,IALI,CAKC5B,MAAM,KAAK6B,WAAL,CAAiB7B,EAAjB,CALP,EAMJ4B,IANI,CAMC5B,MAAM,KAAKtC,kCAAL,CAAwCsC,EAAxC,CANP,CAAP,CAOD,CA5EuC,CA8ExC;AACA;AACA8B,YAAUzB,GAAV,EAAeJ,OAAO,EAAtB,EAA0B,CACxB,KAAK1B,QAAL,CAAcuD,SAAd,CAAwBzB,GAAxB,EAA6BJ,IAA7B,EACGf,IADH,CACQc,MAAM,KAAK6B,WAAL,CAAiB7B,EAAjB,CADd,EAEGd,IAFH,CAEQc,MAAM,KAAKtC,kCAAL,CAAwCsC,EAAxC,CAFd,EAGD,CApFuC,CAsFxC;AACA+B,YAAUtD,GAAV,EAAewB,OAAO,EAAtB,EAA0B,CACxB,OAAO,KAAK1B,QAAL,CAAcyD,eAAd,CAA8BvD,GAA9B,EAAmCwB,IAAnC,EACJf,IADI,CACCc,MAAM,KAAK6B,WAAL,CAAiB7B,EAAjB,CADP,EAEJd,IAFI,CAECc,MAAM,KAAKtC,kCAAL,CAAwCsC,EAAxC,CAFP,CAAP,CADwB,CAItB;AACH,GA5FuC,CA8FxC;AACAiC,UAAQxD,GAAR,EAAawB,OAAO,EAApB,EAAwB,CACtB,KAAK1B,QAAL,CAAc0D,OAAd,CAAsBxD,GAAtB,EAA2BwB,IAA3B,EACGf,IADH,CACQc,MAAM,KAAK6B,WAAL,CAAiB7B,EAAjB,CADd,EAEGd,IAFH,CAEQc,MAAM,KAAKtC,kCAAL,CAAwCsC,EAAxC,CAFd,EAGD,CAnGuC,CAqGxC;AAEA;AACA;AACAkC,WAASC,IAAT,EAAe,CACb,IAAI,CAACA,IAAL,EAAW,CACT9C,QAAQ4B,IAAR,CAAa,qCAAb,EACA,OAAO,mBAAQmB,MAAR,EAAP,CACD,CAJY,CAKb;AACA;AACA,QAAID,KAAKE,UAAT,EAAqB,CACnB,OAAO,KAAKrD,EAAL,CAAQsD,aAAR,CAAsBH,IAAtB,EACJjD,IADI,CACCqD,QAAQA,IADT,EAEJX,IAFI,CAECY,OAAO,KAAKC,QAAL,CAAcD,IAAI7E,GAAlB,EAAuB6E,GAAvB,CAFR,EAGJtD,IAHI,CAGC,MAAM,KAAKwD,gBAAL,CAAsBP,IAAtB,CAHP,CAAP,CAID,CACD,IAAIA,KAAKxE,GAAT,EAAc,CACZ,IAAI,OAAOwE,KAAKxE,GAAZ,KAAoB,QAAxB,EAAkC,CAChC,OAAO,KAAK8E,QAAL,CAAcN,KAAKxE,GAAnB,EAAwBwE,IAAxB,EACJjD,IADI,CACC,MAAM,KAAKwD,gBAAL,CAAsBP,IAAtB,EAA4BA,KAAKxE,GAAjC,CADP,CAAP,CAED,CAHD,MAGO,IAAIgF,MAAMC,OAAN,CAAcT,KAAKxE,GAAnB,CAAJ,EAA6B,CAClC,OAAO,mBAAQkF,GAAR,CAAYV,KAAKxE,GAAjB,EAAsBA,OAAO,KAAKuE,QAAL,cAAmBC,IAAnB,IAAyBxE,GAAzB,IAA7B,CAAP,CACD,CACD0B,QAAQ4B,IAAR,CAAa,wDAAb,EACA,OAAO,mBAAQmB,MAAR,EAAP,CACD,CAtBY,CAuBb;AACA,WAAO,KAAKpD,EAAL,CAAQ8D,WAAR,CAAoBX,IAApB,EACJU,GADI,CACAL,OAAOA,IAAI7E,GADX,EAEJiE,IAFI,CAECjE,OAAO,KAAK8E,QAAL,CAAc9E,GAAd,EAAmBwE,IAAnB,CAFR,CAEkC;AAFlC,MAGJjD,IAHI,CAGCiB,QAAQ,KAAKuC,gBAAL,CAAsBP,IAAtB,EAA4B,iBAAEY,IAAF,CAAO5C,IAAP,CAA5B,CAHT,CAAP,CAID,CArIuC,CAuIxC;AACA;AACA6C,YAAUvE,GAAV,EAAewB,IAAf,EAAqB,CACnB,MAAMgD,UAAU,eAAK7C,MAAL,CAAY,EAC1BC,KAAK,KAAK5C,OADgB,EAE1B6C,MAAML,IAFoB,EAAZ,CAAhB,CAIA,OAAO,KAAK1B,QAAL,CAAcC,MAAd,CAAqBC,GAArB,EACJS,IADI,CACCvB,OAAOA,IAAIuF,MAAJ,CAAWD,OAAX,EAAoBhD,IAApB,CADR,EAEJf,IAFI,CAEC,MAAM,KAAKF,EAAL,CAAQmE,SAAR,CAAkB1E,GAAlB,EAAuBwB,IAAvB,EAA6BgD,OAA7B,CAFP,CAAP,CAGD,CAjJuC,CAmJxC;AACA;AACAG,YAAU3E,GAAV,EAAe4E,YAAY,IAA3B,EAAiC,CAC/B,IAAIC,UAAU,mBAAQ1D,OAAR,EAAd,CACA,IAAIyD,SAAJ,EAAe,CACb,MAAME,YAAY,KAAKhF,QAAL,CAAciF,SAAd,CAAwB/E,GAAxB,CAAlB,CACA,IAAI8E,UAAUE,UAAV,CAAqB,KAAKhG,OAA1B,CAAJ,EAAwC,CACtC6F,UAAU,KAAKtE,EAAL,CAAQoE,SAAR,CAAkB3E,GAAlB,EACPS,IADO,CACF,MAAM,KAAKF,EAAL,CAAQ0E,UAAR,CAAmBjF,GAAnB,CADJ,EAEPS,IAFO,CAEF,MAAM7B,YAAYkG,SAAZ,CAFJ,CAAV,CAGD,CANY,CAOb;;;;;;;;;;;mSAYD,CACD,OAAOD,QACJpE,IADI,CACC,MAAM,KAAKX,QAAL,CAAc6E,SAAd,CAAwB3E,GAAxB,CADP,EAEJS,IAFI,CAEC,MAAM,KAAKF,EAAL,CAAQoE,SAAR,CAAkB3E,GAAlB,CAFP,EAGJS,IAHI,CAGC,MAAM,KAAKF,EAAL,CAAQ0E,UAAR,CAAmBjF,GAAnB,CAHP,CAAP,CAID,CA/KuC,CAiLxC;AACA;AACAkD,uBAAqB,CACnB,OAAO,KAAKF,OAAL,GACJoB,GADI,CACA1C,QAAQA,IADR,EAEJwD,MAFI,CAEGhG,OAAO,EAAEA,IAAIA,GAAJ,IAAW,KAAKY,QAAL,CAAc4B,IAA3B,CAFV,EAGJyB,IAHI,CAGEjE,GAAD,IAAS,CACb0B,QAAQC,GAAR,CAAa,aAAY,gBAAMsE,IAAN,CAAWjG,IAAI0C,GAAf,CAAoB,0CAA7C,EACA,OAAO,KAAK+C,SAAL,CAAezF,IAAIA,GAAnB,EAAwB,KAAxB,CAAP,CACD,CANI,CAAP,CADmB,CAQjB;AACH,GA5LuC,CAsMxC;AACAkE,cAAY7B,EAAZ,EAAgB,CACdX,QAAQC,GAAR,CAAa,eAAcU,GAAGvB,GAAI,mBAAlC,EACA,OAAO,KAAKO,EAAL,CAAQoE,SAAR,CAAkBpD,GAAGvB,GAArB,EACJS,IADI,CACC,MAAM,KAAKF,EAAL,CAAQ6E,MAAR,CAAe7D,GAAGvB,GAAlB,EAAuBuB,GAAGC,IAA1B,EAAgCD,GAAGuD,SAAnC,EAA8CvD,GAAGjB,OAAjD,CADP,EAEJG,IAFI,CAEC,MAAM,KAAK4E,iBAAL,CAAuB9D,EAAvB,CAFP,EAGJR,KAHI,CAGG+B,GAAD,IAAS,CACdlC,QAAQC,GAAR,CAAYiC,GAAZ,EACA,KAAKpC,IAAL,CAAU,OAAV,EAAmBoC,GAAnB,EACD,CANI,EAOJrC,IAPI,CAOC,MAAMc,EAPP,CAAP,CAFc,CASK;AACpB,GAjNuC,CAmNxC;AACA8D,oBAAkB9D,EAAlB,EAAsB,CACpB;AACA;AACA;AACA,QAAIA,GAAG+D,gBAAP,EAAyB,CACvB,OAAO,KAAK/E,EAAL,CAAQgF,mBAAR,CAA4BhE,GAAGvB,GAA/B,EAAoCS,IAApC,CAA0ChB,IAAD,IAAU,CACxDmB,QAAQC,GAAR,CAAYpB,IAAZ,EACA,IAAI,CAACA,KAAKa,OAAN,IAAiBb,KAAKa,OAAL,GAAeiB,GAAGjB,OAAvC,EAAgD,CAC9CM,QAAQC,GAAR,CAAY,wBAAZ,EAAsCpB,KAAKa,OAA3C,EACA,OAAOiB,GAAGiE,cAAH,CAAkB,KAAKhG,aAAvB,EAAsCC,KAAKa,OAAL,IAAgB,CAAtD,CAAP,CACD,CACDM,QAAQC,GAAR,CAAY,eAAZ,EACA,OAAO,IAAP,CACD,CARM,CAAP,CASD,CACD,OAAO,KAAKN,EAAL,CAAQ0E,UAAR,CAAmB1D,GAAGvB,GAAtB,EACJS,IADI,CACC,MAAMc,GAAGiE,cAAH,CAAkB,KAAKhG,aAAvB,CADP,CAAP,CAED,CArOuC,CAuOxC;AAgCA;AACAiC,uBAAqBF,EAArB,EAAyB,CACvB,KAAKhB,EAAL,CAAQkF,gBAAR,CAAyBlE,GAAGvB,GAA5B,EACGS,IADH,CACQ,MAAMc,GAAGmE,wBAAH,EADd,EAEGvC,IAFH,CAEQwC,QAAQ,KAAKC,sBAAL,CAA4BrE,EAA5B,EAAgCoE,KAAK,CAAL,CAAhC,EAAyCA,KAAK,CAAL,CAAzC,CAFhB,EAGG5E,KAHH,GAID,CAED6E,uBAAuBrE,EAAvB,EAA2B3B,IAA3B,EAAiCiG,aAAjC,EAAgDlE,SAAS,aAAzD,EAAwE,CACtE,MAAMmE,eAAe,yBAAWlG,IAAX,EAAiB+B,MAAjB,CAArB,CACA,IAAImE,YAAJ,EAAkB,CAChB,MAAMlC,aAAaiC,cAAcE,IAAd,CAAmB,IAAnB,CAAnB,CACAnF,QAAQC,GAAR,CAAY,gBAAMsE,IAAN,CAAW,aAAX,CAAZ,EAAuCvF,IAAvC,EAA6CgE,UAA7C,EACA,OAAO,KAAKrD,EAAL,CAAQyF,gBAAR,CAAyB,EAC9B9G,KAAKqC,GAAGvB,GADsB,EAE9BiG,QAAQH,aAAaG,MAFS,EAG9BC,OAAOJ,aAAaI,KAHU,EAI9BtC,UAJ8B,EAAzB,CAAP,CAMD,CACD,OAAO,mBAAQzC,OAAR,CAAgB,KAAhB,CAAP,CACD,CA5RuC,CA8RxC;AACA6C,WAAShE,GAAT,EAAc0D,IAAd,EAAoB,CAClB,IAAIyC,WAAW,EAAf,CACA,IAAIzC,KAAKuC,MAAL,IAAevC,KAAKwC,KAApB,IAA6BxC,KAAK9D,IAAtC,EAA4C,CAC1CgB,QAAQC,GAAR,CAAa,gBAAe6C,KAAKuC,MAAO,IAAGvC,KAAKwC,KAAM,IAAGxC,KAAK9D,IAAK,SAAQI,GAAI,EAA/E,EACAmG,WAAW,eAAKJ,IAAL,CAAUrC,KAAKuC,MAAf,EAAuBvC,KAAKwC,KAA5B,EAAmCxC,KAAK9D,IAAxC,CAAX,CACD,CAHD,MAGO,IAAI8D,KAAKuC,MAAL,IAAevC,KAAKwC,KAAxB,EAA+B,CACpCtF,QAAQC,GAAR,CAAa,gBAAe6C,KAAKuC,MAAO,IAAGvC,KAAKwC,KAAM,SAAQlG,GAAI,EAAlE,EACAmG,WAAW,eAAKJ,IAAL,CAAUrC,KAAKuC,MAAf,EAAuBvC,KAAKwC,KAA5B,CAAX,CACD,CAHM,MAGA,IAAIxC,KAAKuC,MAAT,EAAiB,CACtBrF,QAAQC,GAAR,CAAa,gBAAe6C,KAAKuC,MAAO,SAAQjG,GAAI,EAApD,EACAmG,WAAW,eAAKJ,IAAL,CAAUrC,KAAKuC,MAAf,CAAX,CACD,CAHM,MAGA,CACLrF,QAAQC,GAAR,CAAa,gCAA+B6C,KAAKxE,GAAI,EAArD,EACD,CACD,OAAO,KAAKY,QAAL,CAAcsG,eAAd,CAA8BpG,GAA9B,EAAmCmG,QAAnC,CAAP,CACD,CA9SuC,CAgTxC;AACA;AACAlC,mBAAiBP,IAAjB,EAAuBxE,GAAvB,EAA4B,CAC1B,OAAO,KAAKqB,EAAL,CAAQ8F,YAAR,CAAqB3C,IAArB,EAA2BxE,GAA3B,EACJuB,IADI,CACCqD,QAAQA,KAAKoB,MAAL,CAAYoB,OAAO,KAAKC,gBAAL,CAAsBD,GAAtB,CAAnB,CADT,EAEJnD,IAFI,CAECY,OAAO,KAAKyC,aAAL,CAAmBzC,IAAI7E,GAAvB,EAA4B6E,IAAIkC,MAAhC,EAAwClC,IAAImC,KAA5C,EAAmDnC,IAAInE,IAAvD,CAFR,CAAP,CAGD,CAtTuC,CAwTxC;AACA2G,mBAAiBE,KAAjB,EAAwB,CACtB,OAAO,KAAK3G,QAAL,CAAc4G,UAAd,CAAyBD,MAAMvH,GAA/B,EAAoC,eAAK6G,IAAL,CAAUU,MAAMR,MAAhB,EAAwBQ,MAAMP,KAA9B,EAAqCO,MAAM7G,IAA3C,CAApC,CAAP,CACD,CA3TuC,CA6TxC;AACA;AAEA;AAuBA;AA4BA;AAKA;AAxXwC,C,QAA7Bd,O,GAAAA,O,CAmYN,SAASH,aAAT,CAAuBgI,OAAvB,EAAgChE,gBAAhC,EAAkD,CACvD;AACA,MAAIiE,eAAe,eAAKb,IAAL,CAAUc,QAAQC,GAAR,EAAV,EAAyB,iBAAO3E,GAAP,CAAW,SAAX,CAAzB,CAAnB,CACAyE,eAAeD,WAAWC,YAA1B,CAHuD,CAKvD;AACA,MAAI,CAAC,aAAGG,UAAH,CAAcH,YAAd,CAAL,EAAkC,CAChC,aAAGI,SAAH,CAAaJ,YAAb,EACD,CAED,MAAMK,UAAU,IAAInI,OAAJ,CAAY8H,YAAZ,CAAhB,CAVuD,CAWvD;AACA,SAAOK,QAAQvE,IAAR,CAAaC,gBAAb,CAAP,CACD,C,kBAEc7D,O","file":"catalog.js","sourcesContent":["import EventEmitter from 'events';\nimport path from 'path';\nimport fs from 'fs';\nimport Promise from 'bluebird';\nimport chalk from 'chalk';\nimport _ from 'lodash';\nimport rimraf from 'rimraf'; // This will b removed soon\nimport config from './config';\n\nimport Database from './db'; // eslint-disable-line\nimport Multidat from './multidat';\n\nimport parseEntry from './utils/importers';\n// @todo: this.db.close(); should be called on shutdown\n\nconst rimrafAsync = Promise.promisify(rimraf);\n\n// Class definition\nexport class Catalog extends EventEmitter {\n  constructor(baseDir) {\n    super();\n    this.baseDir = baseDir;\n    this.dats = [];\n    this.db = new Database(path.format({\n      dir: this.baseDir,\n      base: 'catalog.db',\n    }));\n    this.multidat = new Multidat(baseDir);\n    this.isReady = false;\n\n    // For bulk imports we'll use queue\n    this.importQueue = [];\n    this.queuing = [];\n    this.queueBatchSize = parseInt(config.get('queueBatchSize'), 10);\n\n    // Now, database functions are passed on from this.db\n    // explicitly declare publicly accessible database functions\n    const publicDatabaseFuncs = [\n      'getDats',\n      'getAuthors',\n      'getCollectionAuthors',\n      'getAuthorLetters',\n      'getCollections',\n      'getTitlesWith',\n      'search',\n      'getTitlesForAuthor',\n      'setDownloaded',\n    ];\n\n    publicDatabaseFuncs.forEach((fn) => {\n      if (typeof this.db[fn] === 'function') this[fn] = (...args) => this.db[fn](...args);\n      else console.warn(`Database function \"${fn}\" does not exist and has not been attached to Catalog object.`);\n    });\n\n    const publicMultidatFuncs = ['copyFromDatToDat'];\n\n    publicMultidatFuncs.forEach((fn) => {\n      if (typeof this.multidat[fn] === 'function') this[fn] = (...args) => this.multidat[fn](...args);\n      else console.warn(`Multidat function \"${fn}\" does not exist and has not been attached to Catalog object.`);\n    });\n  }\n\n  init(databaseOnlyMode) {\n    if (databaseOnlyMode) {\n      return this.initDatabase().then(() => this);\n    }\n    return this.initDatabase()\n      .then(() => this.initMultidat())\n      .then(() => {\n        this.emit('ready');\n      })\n      .catch(err => this.emit('error', err))\n      .then(() => this);\n  }\n\n  close() {\n    // close all dats\n    return this.multidat.close()\n      .then(() => this.emit('closed'))\n      .catch(err => this.emit('error', err));\n  }\n\n  initDatabase() {\n    return this.db.init();\n  }\n\n  initMultidat() {\n    return this.multidat.init()\n      .then(() => this.getDats())\n      .then(dats => this.multidat.initOthers(dats))\n      .then(() => this.cleanupDatRegistry())\n      .then(() => this.multidat.getDats())\n      .each(dw => this.registerDat(dw))\n      .each(dw => this.attachEventListenersAndJoinNetwork(dw));\n  }\n\n  // Two functions for adding things into the catalog\n  // Imports a local directory as a dat into the catalog\n  importDir(dir, name = '') {\n    this.multidat.importDir(dir, name)\n      .then(dw => this.registerDat(dw))\n      .then(dw => this.attachEventListenersAndJoinNetwork(dw));\n  }\n\n  // Imports a remote dat repository into the catalog\n  importDat(key, name = '') {\n    return this.multidat.importRemoteDat(key, name)\n      .then(dw => this.registerDat(dw))\n      .then(dw => this.attachEventListenersAndJoinNetwork(dw));\n      // .catch(Error, () => console.log(`Dat ${key} failed to import.`));\n  }\n\n  // Forks a dat (by its key) into a new, writable dat\n  forkDat(key, name = '') {\n    this.multidat.forkDat(key, name)\n      .then(dw => this.registerDat(dw))\n      .then(dw => this.attachEventListenersAndJoinNetwork(dw));\n  }\n\n  // See db functions in constructor for browsing and searching the catalog.\n\n  // Public call for syncing files within a dat\n  // opts can include {dat:, author: , title:, file: }\n  checkout(opts) {\n    if (!opts) {\n      console.warn('attempted to checkout without opts.');\n      return Promise.reject();\n    }\n    // When the collection option is provided it's handled in a special way\n    // because it is downloading across & within authors and maybe across dats\n    if (opts.collection) {\n      return this.db.getTitlesWith(opts)\n        .then(rows => rows)\n        .each(row => this.download(row.dat, row))\n        .then(() => this.scanForDownloads(opts));\n    }\n    if (opts.dat) {\n      if (typeof opts.dat === 'string') {\n        return this.download(opts.dat, opts)\n          .then(() => this.scanForDownloads(opts, opts.dat));\n      } else if (Array.isArray(opts.dat)) {\n        return Promise.map(opts.dat, dat => this.checkout({ ...opts, dat }));\n      }\n      console.warn('dat option passed to check is not an array or a string');\n      return Promise.reject();\n    }\n    // With no dat provided, we must query for it\n    return this.db.getDatsWith(opts)\n      .map(row => row.dat)\n      .each(dat => this.download(dat, opts)) // .each() passes through the original array\n      .then(dats => this.scanForDownloads(opts, _.uniq(dats)));\n  }\n\n  // ## Dat Management, public functions\n  // Rename a dat - updates DB and dat\n  renameDat(key, name) {\n    const newPath = path.format({\n      dir: this.baseDir,\n      base: name,\n    });\n    return this.multidat.getDat(key)\n      .then(dat => dat.rename(newPath, name))\n      .then(() => this.db.updateDat(key, name, newPath));\n  }\n\n  // Delete a dat from registry.\n  // Only deletes directory if it's in the baseDir\n  removeDat(key, deleteDir = true) {\n    let promise = Promise.resolve();\n    if (deleteDir) {\n      const directory = this.multidat.pathToDat(key);\n      if (directory.startsWith(this.baseDir)) {\n        promise = this.db.removeDat(key)\n          .then(() => this.db.clearTexts(key))\n          .then(() => rimrafAsync(directory));\n      }\n      /*\n      // @todo: fix this because it is better I think?\n      return this.multidat.pathToDat(key)\n        .then((p) => {\n          if (p.startsWith(this.baseDir)) {\n            return this.db.removeDat(key)\n              .then(() => this.db.clearTexts(key))\n              .then(() => this.multidat.deleteDat(key));\n          }\n          return this.removeDat(key, false);\n        });\n      */\n    }\n    return promise\n      .then(() => this.multidat.removeDat(key))\n      .then(() => this.db.removeDat(key))\n      .then(() => this.db.clearTexts(key));\n  }\n\n  // ### private functions\n  // Remove dats that are in the DB but haven't been found/ loaded by multidat\n  cleanupDatRegistry() {\n    return this.getDats()\n      .map(dats => dats)\n      .filter(dat => !(dat.dat in this.multidat.dats))\n      .each((dat) => {\n        console.log(`Removing: ${chalk.bold(dat.dir)} from catalog (directory does not exist)`);\n        return this.removeDat(dat.dat, false);\n      });\n      // .then(() => this.db.clearTexts());\n  }\n\n  attachEventListenersAndJoinNetwork = (dat) => {\n    dat.on('import', this.handleDatImportEvent);\n    dat.on('download metadata', this.handleDatDownloadMetadataEvent);\n    dat.on('sync metadata', this.handleDatSyncMetadataEvent);\n    // dat.on('sync collections', this.handleDatSyncCollectionsEvent);\n    return dat.run();\n  }\n\n  // Registers dat the DB\n  registerDat(dw) {\n    console.log(`Adding dat (${dw.key}) to the catalog.`);\n    return this.db.removeDat(dw.key)\n      .then(() => this.db.addDat(dw.key, dw.name, dw.directory, dw.version))\n      .then(() => this.ingestDatContents(dw))\n      .catch((err) => {\n        console.log(err);\n        this.emit('error', err);\n      })\n      .then(() => dw); // at this point we should add all texts within the metadata;\n  }\n\n  // For a Dat, ingest its contents into the catalog\n  ingestDatContents(dw) {\n    // rather than clear texts check if metadata is complete\n    // only ingest if dat version is > max db version for key\n    // or if metadata is incomplete,\n    if (dw.metadataComplete) {\n      return this.db.lastImportedVersion(dw.key).then((data) => {\n        console.log(data);\n        if (!data.version || data.version < dw.version) {\n          console.log('importing from version', data.version);\n          return dw.onEachMetadata(this.ingestDatFile, data.version || 1);\n        }\n        console.log('not importing');\n        return null;\n      });\n    }\n    return this.db.clearTexts(dw.key)\n      .then(() => dw.onEachMetadata(this.ingestDatFile));\n  }\n\n  // Adds an entry from a Dat\n  ingestDatFile = async (data, attempts = 10) => {\n    // console.log('trying to import:', data.type, ':', data.file, data.progress);\n    const entry = parseEntry(data.file, 'calibre');\n    if (entry) {\n      const downloaded = await this.multidat.getDat(data.key).hasFile(data.file);\n      const downloadedStr = (downloaded) ? '[*]' : '[ ]';\n      // console.log(chalk.bold('adding:'), downloadedStr, data.file);\n      const text = {\n        dat: data.key,\n        state: data.type === 'put',\n        version: data.version,\n        ...entry,\n        downloaded,\n      };\n      return this.db.addTextFromMetadata(text)\n        .then(() => this.emit('import', { ...text, progress: data.progress }))\n        .then(() => {\n          console.log(`${data.progress.toFixed(2)}%`, 'adding:', downloadedStr, data.file);\n        })\n        .catch((e) => {\n          if (attempts > 0) {\n            console.log('retry', attempts);\n            return Promise.delay(1000).then(() => this.ingestDatFile(data, attempts - 1));\n          }\n          console.error('errrored', e);\n          return null;\n        });\n    }\n    return Promise.resolve(false);\n  }\n\n  // For a Dat, ingest its collections data (if there are any)\n  ingestDatCollections(dw) {\n    this.db.clearCollections(dw.key)\n      .then(() => dw.listFlattenedCollections())\n      .each(item => this.ingestDatCollectedFile(dw, item[0], item[1]))\n      .catch();\n  }\n\n  ingestDatCollectedFile(dw, file, collectionArr, format = 'authorTitle') {\n    const importedData = parseEntry(file, format);\n    if (importedData) {\n      const collection = collectionArr.join(';;');\n      console.log(chalk.bold('collecting:'), file, collection);\n      return this.db.addCollectedText({\n        dat: dw.key,\n        author: importedData.author,\n        title: importedData.title,\n        collection,\n      });\n    }\n    return Promise.resolve(false);\n  }\n\n  // Downloads files within a dat\n  download(key, opts) {\n    let resource = '';\n    if (opts.author && opts.title && opts.file) {\n      console.log(`checking out ${opts.author}/${opts.title}/${opts.file} from ${key}`);\n      resource = path.join(opts.author, opts.title, opts.file);\n    } else if (opts.author && opts.title) {\n      console.log(`checking out ${opts.author}/${opts.title} from ${key}`);\n      resource = path.join(opts.author, opts.title);\n    } else if (opts.author) {\n      console.log(`checking out ${opts.author} from ${key}`);\n      resource = path.join(opts.author);\n    } else {\n      console.log(`checking out everything from ${opts.dat}`);\n    }\n    return this.multidat.downloadFromDat(key, resource);\n  }\n\n  // Checks whether a group of catalogue items have been downloaded\n  // and if so, then updates the downloaded column in the texts table\n  scanForDownloads(opts, dat) {\n    return this.db.getItemsWith(opts, dat)\n      .then(rows => rows.filter(doc => this.itemIsDownloaded(doc)))\n      .each(row => this.setDownloaded(row.dat, row.author, row.title, row.file));\n  }\n\n  // Given a row from the texts table, check if it has been downloaded\n  itemIsDownloaded(dbRow) {\n    return this.multidat.datHasFile(dbRow.dat, path.join(dbRow.author, dbRow.title, dbRow.file));\n  }\n\n  // Event listening\n  //\n\n  // When a dat imports a file\n  handleDatImportEvent = (data) => {\n    console.log(`${data.progress.toFixed(2)}%`, 'import download event.', data.type, ':', data.file);\n    const entry = parseEntry(data.file, 'calibre');\n    if (entry) {\n      const text = {\n        dat: data.key,\n        state: data.type === 'put',\n        version: data.version,\n        ...entry,\n        downloaded: true, // downloaed is true as you are importing it, right?\n      };\n      // if this times out we should implement a simple promise queue,\n      // so that we just these requests to a list that gets executed when\n      // the preceeding functions .then is called.\n      this.db.addTextFromMetadata(text)\n        .then(() => this.emit('import', { ...text, progress: data.progress }))\n        .catch(console.error);\n    } else {\n      console.log(`cannot import ${data.file}: maybe not calibre formated?`);\n    }\n  }\n\n  // When a dat's metadata is synced\n  handleDatDownloadMetadataEvent = (data) => {\n    // this is almost identical to import MetadataEvent except for download flag - TODO: refactor to reduce duplication.\n    console.log(`${data.progress.toFixed(2)}%`, 'Metadata download event.', data.type, ':', data.file);\n    const entry = parseEntry(data.file, 'calibre');\n    if (entry) {\n      const text = {\n        dat: data.key,\n        state: data.type === 'put',\n        version: data.version,\n        ...entry,\n        downloaded: false, // need to check for downloaded - probaby at this point does not makes sense as we have not even downloaded the metadata.\n      };\n      // if this times out we should implement a simple promise queue,\n      // so that we just these requests to a list that gets executed when\n      // the preceeding functions .then is called.\n      this.db.addTextFromMetadata(text)\n        .then(() => this.emit('import', { ...text, progress: data.progress }))\n        .catch(console.error);\n    } else {\n      console.log(`cannot import ${data.file}: maybe not calibre formated?`);\n    }\n  }\n\n  handleDatSyncMetadataEvent = (dat) => {\n    console.log('Metadata sync event. Ingesting contents for:', dat);\n  }\n\n  // When a dat import process is finished\n  handleDatListingEvent = (data) => {\n    console.log('Importing: ', data);\n  }\n\n  // When a dat import process is finished\n  handleDatListingEndEvent = (data) => {\n    console.log(data);\n  }\n\n  handleDatSyncCollectionsEvent = (dw) => {\n    console.log('Collections sync event. Ingesting collections for:', dw.name);\n    this.ingestDatCollections(dw);\n  }\n}\n\nexport function createCatalog(dataDir, databaseOnlyMode) {\n  // Directory to store all the data in\n  let dataDirFinal = path.join(process.cwd(), config.get('dataDir'));\n  dataDirFinal = dataDir || dataDirFinal;\n\n  // Create data directory if it doesn't exist yet\n  if (!fs.existsSync(dataDirFinal)) {\n    fs.mkdirSync(dataDirFinal);\n  }\n\n  const catalog = new Catalog(dataDirFinal);\n  // @todo: adjust init() to not load any dats, allowing for quick db searches\n  return catalog.init(databaseOnlyMode);\n}\n\nexport default Catalog;\n"]}