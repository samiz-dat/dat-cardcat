{"version":3,"sources":["../src/catalog.js"],"names":["createCatalog","rimrafAsync","promisify","prepareCatalogDir","dataDir","dataDirFinal","join","process","cwd","get","existsSync","mkdirSync","Catalog","constructor","baseDir","attachEventListenersAndJoinNetwork","dat","on","handleDatImportEvent","handleDatDownloadMetadataEvent","handleDatSyncMetadataEvent","run","ingestDatFile","data","attempts","entry","file","downloaded","multidat","getDat","key","hasFile","downloadedStr","text","state","type","version","db","addTextFromMetadata","then","emit","progress","console","log","toFixed","catch","e","delay","error","startsWith","resolve","handleDatListingEvent","handleDatListingEndEvent","handleDatSyncCollectionsEvent","dw","name","ingestDatCollections","dats","format","dir","base","ignore","promise","isReady","importQueue","queuing","queueBatchSize","parseInt","publicDatabaseFuncs","forEach","fn","args","warn","publicMultidatFuncs","init","databaseOnlyMode","initDatabase","initMultidat","err","close","getDats","initOthers","cleanupDatRegistry","each","registerDat","importDir","importDat","importRemoteDat","forkDat","checkout","opts","reject","collection","getTitlesWith","rows","row","download","scanForDownloads","Array","isArray","map","getDatsWith","uniq","renameDat","newPath","rename","updateDat","removeDat","deleteDir","directory","pathToDat","clearTexts","filter","bold","addDat","ingestDatContents","metadataComplete","lastImportedVersion","onEachMetadata","ingestDatCollectedFile","collectionArr","importedData","author","title","addCollectedText","ingestDatCollection","n","clearCollections","loadCollection","item","concat","finally","informationAboutCollection","subcoll","split","coll","shift","getAvailableCollections","allCollections","arr","items","push","resource","downloadFromDat","getItemsWith","doc","itemIsDownloaded","setDownloaded","dbRow","datHasFile","catalog"],"mappings":"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","file":"catalog.js","sourcesContent":["import EventEmitter from 'events';\nimport path from 'path';\nimport fs from 'fs';\nimport Promise from 'bluebird';\nimport chalk from 'chalk';\nimport _ from 'lodash';\nimport rimraf from 'rimraf'; // This will b removed soon\nimport config from './config';\n\nimport Database from './db'; // eslint-disable-line\nimport Multidat from './multidat';\n\nimport parseEntry from './utils/importers';\nimport sequentialise from './utils/sequentialise';\n// @todo: this.db.close(); should be called on shutdown\n\nconst rimrafAsync = Promise.promisify(rimraf);\n\n// Ensures that the catalog directory will be available\nfunction prepareCatalogDir(dataDir) {\n  // Directory to store all the data in\n  let dataDirFinal = path.join(process.cwd(), config.get('dataDir'));\n  dataDirFinal = dataDir || dataDirFinal;\n  // Create data directory if it doesn't exist yet\n  if (!fs.existsSync(dataDirFinal)) {\n    fs.mkdirSync(dataDirFinal);\n  }\n  return dataDirFinal;\n}\n\n// Class definition\nexport class Catalog extends EventEmitter {\n  constructor(baseDir) {\n    super();\n    this.baseDir = prepareCatalogDir(baseDir);\n    this.dats = [];\n    this.db = sequentialise(new Database(path.format({\n      dir: this.baseDir,\n      base: 'catalog.db',\n    })), {\n      ignore: ['db'],\n      promise: Promise,\n    });\n    this.multidat = new Multidat(this.baseDir);\n    this.isReady = false;\n\n    // For bulk imports we'll use queue\n    this.importQueue = [];\n    this.queuing = [];\n    this.queueBatchSize = parseInt(config.get('queueBatchSize'), 10);\n\n    // Now, database functions are passed on from this.db\n    // explicitly declare publicly accessible database functions\n    const publicDatabaseFuncs = [\n      'getDats',\n      'getAuthors',\n      'getCollectionAuthors',\n      'getAuthorLetters',\n      'getCollections',\n      'getTitlesWith',\n      'search',\n      'getTitlesForAuthor',\n      'setDownloaded',\n    ];\n\n    publicDatabaseFuncs.forEach((fn) => {\n      if (typeof this.db[fn] === 'function') this[fn] = (...args) => this.db[fn](...args);\n      else console.warn(`Database function \"${fn}\" does not exist and has not been attached to Catalog object.`);\n    });\n\n    const publicMultidatFuncs = ['copyFromDatToDat'];\n\n    publicMultidatFuncs.forEach((fn) => {\n      if (typeof this.multidat[fn] === 'function') this[fn] = (...args) => this.multidat[fn](...args);\n      else console.warn(`Multidat function \"${fn}\" does not exist and has not been attached to Catalog object.`);\n    });\n  }\n\n  init(databaseOnlyMode) {\n    if (databaseOnlyMode) {\n      return this.initDatabase().then(() => this);\n    }\n    return this.initDatabase()\n      .then(() => this.initMultidat())\n      .then(() => {\n        this.emit('ready');\n      })\n      .catch(err => this.emit('error', err))\n      .then(() => this);\n  }\n\n  close() {\n    // close all dats\n    return this.multidat.close()\n      .then(() => this.emit('closed'))\n      .catch(err => this.emit('error', err));\n  }\n\n  initDatabase() {\n    return this.db.init();\n  }\n\n  initMultidat() {\n    return this.multidat.init()\n      .then(() => this.getDats())\n      .then(dats => this.multidat.initOthers(dats))\n      .then(() => this.cleanupDatRegistry())\n      .then(() => this.multidat.getDats())\n      .each(dw => this.registerDat(dw))\n      .each(dw => this.attachEventListenersAndJoinNetwork(dw));\n  }\n\n  // Two functions for adding things into the catalog\n  // Imports a local directory as a dat into the catalog\n  importDir(dir, name = '') {\n    this.multidat.importDir(dir, name)\n      .then(dw => this.registerDat(dw))\n      .then(dw => this.attachEventListenersAndJoinNetwork(dw));\n  }\n\n  // Imports a remote dat repository into the catalog\n  importDat(key, name = '') {\n    return this.multidat.importRemoteDat(key, name)\n      .then(dw => this.registerDat(dw))\n      .then(dw => this.attachEventListenersAndJoinNetwork(dw));\n      // .catch(Error, () => console.log(`Dat ${key} failed to import.`));\n  }\n\n  // Forks a dat (by its key) into a new, writable dat\n  forkDat(key, name = '') {\n    this.multidat.forkDat(key, name)\n      .then(dw => this.registerDat(dw))\n      .then(dw => this.attachEventListenersAndJoinNetwork(dw));\n  }\n\n  // See db functions in constructor for browsing and searching the catalog.\n\n  // Public call for syncing files within a dat\n  // opts can include {dat:, author: , title:, file: }\n  checkout(opts) {\n    if (!opts) {\n      console.warn('attempted to checkout without opts.');\n      return Promise.reject();\n    }\n    // When the collection option is provided it's handled in a special way\n    // because it is downloading across & within authors and maybe across dats\n    if (opts.collection) {\n      return this.db.getTitlesWith(opts)\n        .then(rows => rows)\n        .each(row => this.download(row.dat, row))\n        .then(() => this.scanForDownloads(opts));\n    }\n    if (opts.dat) {\n      if (typeof opts.dat === 'string') {\n        return this.download(opts.dat, opts)\n          .then(() => this.scanForDownloads(opts, opts.dat));\n      } else if (Array.isArray(opts.dat)) {\n        return Promise.map(opts.dat, dat => this.checkout({ ...opts, dat }));\n      }\n      console.warn('dat option passed to check is not an array or a string');\n      return Promise.reject();\n    }\n    // With no dat provided, we must query for it\n    return this.db.getDatsWith(opts)\n      .map(row => row.dat)\n      .each(dat => this.download(dat, opts)) // .each() passes through the original array\n      .then(dats => this.scanForDownloads(opts, _.uniq(dats)));\n  }\n\n  // ## Dat Management, public functions\n  // Rename a dat - updates DB and dat\n  renameDat(key, name) {\n    const newPath = path.format({\n      dir: this.baseDir,\n      base: name,\n    });\n    return this.multidat.getDat(key)\n      .then(dat => dat.rename(newPath, name))\n      .then(() => this.db.updateDat(key, name, newPath));\n  }\n\n  // Delete a dat from registry.\n  // Only deletes directory if it's in the baseDir\n  removeDat(key, deleteDir = true) {\n    let promise = Promise.resolve();\n    if (deleteDir) {\n      const directory = this.multidat.pathToDat(key);\n      if (directory.startsWith(this.baseDir)) {\n        promise = this.db.removeDat(key)\n          .then(() => this.db.clearTexts(key))\n          .then(() => rimrafAsync(directory));\n      }\n      /*\n      // @todo: fix this because it is better I think?\n      return this.multidat.pathToDat(key)\n        .then((p) => {\n          if (p.startsWith(this.baseDir)) {\n            return this.db.removeDat(key)\n              .then(() => this.db.clearTexts(key))\n              .then(() => this.multidat.deleteDat(key));\n          }\n          return this.removeDat(key, false);\n        });\n      */\n    }\n    return promise\n      .then(() => this.multidat.removeDat(key))\n      .then(() => this.db.removeDat(key))\n      .then(() => this.db.clearTexts(key));\n  }\n\n  // ### private functions\n  // Remove dats that are in the DB but haven't been found/ loaded by multidat\n  cleanupDatRegistry() {\n    return this.getDats()\n      .map(dats => dats)\n      .filter(dat => !(dat.dat in this.multidat.dats))\n      .each((dat) => {\n        console.log(`Removing: ${chalk.bold(dat.dir)} from catalog (directory does not exist)`);\n        return this.removeDat(dat.dat, false);\n      });\n      // .then(() => this.db.clearTexts());\n  }\n\n  attachEventListenersAndJoinNetwork = (dat) => {\n    dat.on('import', this.handleDatImportEvent);\n    dat.on('download metadata', this.handleDatDownloadMetadataEvent);\n    dat.on('sync metadata', this.handleDatSyncMetadataEvent);\n    return dat.run();\n  }\n\n  // Registers dat the DB\n  registerDat(dw) {\n    console.log(`Adding dat (${dw.key}) to the catalog.`);\n    return this.db.removeDat(dw.key)\n      .then(() => this.db.addDat(dw.key, dw.name, dw.directory, dw.version))\n      .then(() => this.ingestDatContents(dw))\n      .catch((err) => {\n        console.log(err);\n        this.emit('error', err);\n      })\n      .then(() => dw); // at this point we should add all texts within the metadata;\n  }\n\n  // For a Dat, ingest its contents into the catalog\n  ingestDatContents(dw) {\n    // rather than clear texts check if metadata is complete\n    // only ingest if dat version is > max db version for key\n    // or if metadata is incomplete,\n    if (dw.metadataComplete) {\n      return this.db.lastImportedVersion(dw.key).then((data) => {\n        console.log(data);\n        if (!data.version || data.version < dw.version) {\n          console.log('importing from version', data.version + 1, 'to version', dw.version);\n          return dw.onEachMetadata(this.ingestDatFile, data.version + 1 || 1);\n        }\n        console.log('not importing. already at version ', data.version);\n        return null;\n      });\n    }\n    return this.db.clearTexts(dw.key)\n      .then(() => dw.onEachMetadata(this.ingestDatFile));\n  }\n\n  // Adds an entry from a Dat\n  ingestDatFile = async (data, attempts = 10) => {\n    // console.log('trying to import:', data.type, ':', data.file, data.progress);\n    const entry = parseEntry(data.file, 'calibre');\n    if (entry) {\n      const downloaded = await this.multidat.getDat(data.key).hasFile(data.file);\n      const downloadedStr = (downloaded) ? '[*]' : '[ ]';\n      // console.log(chalk.bold('adding:'), downloadedStr, data.file);\n      const text = {\n        dat: data.key,\n        state: data.type === 'put',\n        version: data.version,\n        ...entry,\n        downloaded,\n      };\n      return this.db.addTextFromMetadata(text)\n        .then(() => this.emit('import', { ...text, progress: data.progress }))\n        .then(() => {\n          console.log(`${data.progress.toFixed(2)}%`, 'adding:', downloadedStr, data.file);\n        })\n        .catch((e) => {\n          if (attempts > 0) {\n            console.log('retry', attempts);\n            return Promise.delay(1000).then(() => this.ingestDatFile(data, attempts - 1));\n          }\n          console.error('errrored', e);\n          return null;\n        });\n    // Special case of a collections file\n    } else if (data.file.startsWith('/dat-collections/') && data.type === 'put') {\n      // const dw = await this.multidat.getDat(data.key);\n      // return this.ingestDatCollections(dw);\n    }\n    return Promise.resolve(false);\n  }\n\n  ingestDatCollectedFile(dw, file, collectionArr, format = 'authorTitle') {\n    const importedData = parseEntry(file, format);\n    if (importedData) {\n      const collection = collectionArr.join(';;');\n      console.log(chalk.bold('collecting:'), file, collection);\n      const data = {\n        dat: dw.key,\n        author: importedData.author,\n        title: importedData.title,\n        collection,\n      };\n      return this.db.addCollectedText(data);\n    }\n    return Promise.resolve(false);\n  }\n\n  ingestDatCollection(name, key) {\n    const n = [name];\n    return this.db.clearCollections(key, name)\n    .then(() => this.multidat.getDat(key))\n    .then(dw => dw.loadCollection(name)\n      // The collection name needs to be added to the beginning of item[1]\n      .each(item => this.ingestDatCollectedFile(dw, item[0], n.concat(item[1]))))\n    .catch(() => {})\n    .finally(() => this.emit('collections updated'));\n  }\n\n  // Returns { title:, description:} for a collection name (could include subcollection!)\n  informationAboutCollection(name, key) {\n    const subcoll = name.split(';;');\n    const coll = subcoll.shift();\n    const dw = this.multidat.getDat(key);\n    return dw.informationAboutCollection(coll, subcoll);\n  }\n\n  // Gets a list of all available Collections suggested by the loaded dats\n  getAvailableCollections() {\n    console.log('Building list of available collections');\n    const allCollections = [];\n    const dats = this.multidat.getDats();\n    return Promise.map(dats, dw =>\n      dw.getAvailableCollections()\n      .map(collection => [collection, dw.key]))\n    .then(arr => arr[0])\n    .then(items => allCollections.push(...items))\n    .then(() => allCollections);\n  }\n\n  // Downloads files within a dat\n  download(key, opts) {\n    let resource = '';\n    if (opts.author && opts.title && opts.file) {\n      console.log(`checking out ${opts.author}/${opts.title}/${opts.file} from ${key}`);\n      resource = path.join(opts.author, opts.title, opts.file);\n    } else if (opts.author && opts.title) {\n      console.log(`checking out ${opts.author}/${opts.title} from ${key}`);\n      resource = path.join(opts.author, opts.title);\n    } else if (opts.author) {\n      console.log(`checking out ${opts.author} from ${key}`);\n      resource = path.join(opts.author);\n    } else {\n      console.log(`checking out everything from ${opts.dat}`);\n    }\n    return this.multidat.downloadFromDat(key, resource);\n  }\n\n  // Checks whether a group of catalogue items have been downloaded\n  // and if so, then updates the downloaded column in the texts table\n  scanForDownloads(opts, dat) {\n    return this.db.getItemsWith(opts, dat)\n      .then(rows => rows.filter(doc => this.itemIsDownloaded(doc)))\n      .each(row => this.setDownloaded(row.dat, row.author, row.title, row.file));\n  }\n\n  // Given a row from the texts table, check if it has been downloaded\n  itemIsDownloaded(dbRow) {\n    return this.multidat.datHasFile(dbRow.dat, path.join(dbRow.author, dbRow.title, dbRow.file));\n  }\n\n  // Event listening\n  //\n\n  // When a dat imports a file\n  handleDatImportEvent = (data) => {\n    console.log(`${data.progress.toFixed(2)}%`, 'import download event.', data.type, ':', data.file);\n    const entry = parseEntry(data.file, 'calibre');\n    if (entry) {\n      const text = {\n        dat: data.key,\n        state: data.type === 'put',\n        version: data.version,\n        ...entry,\n        downloaded: true, // downloaed is true as you are importing it, right?\n      };\n      // if this times out we should implement a simple promise queue,\n      // so that we just these requests to a list that gets executed when\n      // the preceeding functions .then is called.\n      this.db.addTextFromMetadata(text)\n        .then(() => this.emit('import', { ...text, progress: data.progress }))\n        .catch(console.error);\n    } else {\n      console.log(`cannot import ${data.file}: maybe not calibre formated?`);\n    }\n  }\n\n  // When a dat's metadata is synced\n  handleDatDownloadMetadataEvent = (data) => {\n    // this is almost identical to import MetadataEvent except for download flag - TODO: refactor to reduce duplication.\n    console.log(`${data.progress.toFixed(2)}%`, 'Metadata download event.', data.type, ':', data.file);\n    const entry = parseEntry(data.file, 'calibre');\n    if (entry) {\n      const text = {\n        dat: data.key,\n        state: data.type === 'put',\n        version: data.version,\n        ...entry,\n        downloaded: false, // need to check for downloaded - probaby at this point does not makes sense as we have not even downloaded the metadata.\n      };\n      // if this times out we should implement a simple promise queue,\n      // so that we just these requests to a list that gets executed when\n      // the preceeding functions .then is called.\n      this.db.addTextFromMetadata(text)\n        .then(() => this.emit('import', { ...text, progress: data.progress }))\n        .catch(console.error);\n    } else {\n      console.log(`cannot import ${data.file}: maybe not calibre formated?`);\n    }\n  }\n\n  handleDatSyncMetadataEvent = (dat) => {\n    console.log('Metadata sync event. Ingesting contents for:', dat);\n  }\n\n  // When a dat import process is finished\n  handleDatListingEvent = (data) => {\n    console.log('Importing: ', data);\n  }\n\n  // When a dat import process is finished\n  handleDatListingEndEvent = (data) => {\n    console.log(data);\n  }\n\n  handleDatSyncCollectionsEvent = (dw) => {\n    console.log('Collections sync event. Ingesting collections for:', dw.name);\n    this.ingestDatCollections(dw);\n  }\n}\n\nexport function createCatalog(dataDir, databaseOnlyMode) {\n  const catalog = new Catalog(dataDir);\n  return catalog.init(databaseOnlyMode);\n}\n\nexport default Catalog;\n"]}