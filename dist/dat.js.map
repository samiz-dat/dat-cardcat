{"version":3,"sources":["../src/dat.js"],"names":["DatWrapper","constructor","opts","hasFile","file","r","access","join","directory","F_OK","e","exitHandler","options","error","cleanup","console","log","dat","leave","importer","destroy","stack","exit","process","existsSync","mkdirSync","key","name","stats","latest","indexing","collections","run","create","then","toString","network","joinNetwork","trackStats","importFiles","once","gray","bold","peers","archive","on","metadata","emit","createDatAsync","promisify","total","complete","version","importPath","resolve","reject","writable","watch","dereference","src","replace","stat","importFromDat","srcDatWrapper","fileOrDir","overwriteExisting","dstPath","exportArchiveToFilesystem","srcArchive","srcPath","listContents","below","readdir","recursive","replayHistory","sinceVersion","stream","history","start","data","pumpContents","fs","filepath","downloadContent","fn","filename","download","rename","dir","renameAsync","listFlattenedCollections","flatten","writeManifest","manifest","url","title","readManifest","updateManifest","close","err"],"mappings":"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","file":"dat.js","sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport EventEmitter from 'events';\nimport createDat from 'dat-node';\nimport Collections from 'dat-collections';\n// import _ from 'lodash';\nimport Promise from 'bluebird';\nimport chalk from 'chalk';\nimport pda from 'pauls-dat-api';\nimport walker from 'folder-walker';\nimport through from 'through2';\nimport pumpify from 'pumpify';\n\n// import { lsFilesPromised } from './utils/filesystem';\n\n// fork() - download a dat and fork it (thru dat.json)\n// list() - lists files\n// download() - downloads some files\n// read/writeManifest()\n// health/ stats\n\n/**\n * Adds Library-ish functions to a Dat. Expects the Dat's directory structure to\n * follow Calibre's (Author Name/ Publication Title/ Files)\n */\nexport default class DatWrapper extends EventEmitter {\n  constructor(opts) {\n    super();\n    this.directory = opts.directory;\n    // create if it doesn't exist\n    if (!fs.existsSync(opts.directory)) {\n      fs.mkdirSync(opts.directory);\n    }\n    this.key = opts.key;\n    this.name = opts.name;\n    this.stats = false;\n    this.opts = opts;\n    // Don't need the whole history (also we do need files as files)\n    this.opts.latest = true;\n    // If we're creating/ hosting a dat, set indexing to true\n    // this.opts.indexing = !this.key;\n    this.opts.indexing = true;\n    this.importer = false;\n    // Collections\n    this.collections = false;\n  }\n\n  // Creates a dat and grabs a key\n  // Perhaps this gets rewritten to be more like beaker:\n  // https://github.com/beakerbrowser/beaker/blob/2c2336430bdb00ea8e47e13fb2e8c8d5b89440ea/app/background-process/networks/dat/dat.js#L231\n  run() {\n    return this.create()\n      .then((dat) => {\n        this.dat = dat;\n        this.key = dat.key.toString('hex');\n        // const opts = {}; // various network options could go here (https://github.com/datproject/dat-node)\n        const network = dat.joinNetwork();\n        this.stats = dat.trackStats();\n\n        this.importFiles();\n        /*\n        stats.once('update', () => {\n          console.log(chalk.gray(chalk.bold('stats updated')), stats.get());\n        });\n        */\n        network.once('connection', () => {\n          console.log('connects via network');\n          console.log(chalk.gray(chalk.bold('peers:')), this.stats.peers);\n        });\n        this.collections = new Collections(dat.archive);\n        this.collections.on('loaded', () => {\n          console.log(`collections data loaded (${this.name})`);\n          // this.emit('sync collections', this);\n        });\n\n        // this.start(dat);\n        // Watch for metadata syncing\n        dat.archive.metadata.on('sync', () => {\n          console.log('metadata synced');\n          this.emit('sync metadata', this);\n          // @todo: remove this next hack line.\n          // But for now we need it because on first load of dat we aren't getting the \"loaded\" event above\n          this.emit('sync collections', this);\n        });\n      })\n      // .then(() => this.importFiles())\n      .then(() => this);\n  }\n\n  // Just creates a dat object\n  create() {\n    const createDatAsync = Promise.promisify(createDat);\n    return createDatAsync(this.directory, this.opts);\n  }\n\n  // How many peers for this dat\n  get peers() {\n    return this.stats.peers || { total: 0, complete: 0 };\n  }\n\n  get version() {\n    return this.dat.archive.version;\n  }\n\n  importFiles(importPath = this.directory) {\n    return new Promise((resolve, reject) => {\n      const dat = this.dat;\n      if (this.dat.writable) {\n        console.log('Importing files under:', importPath);\n        const opts = {\n          watch: true,\n          dereference: true,\n          indexing: true,\n        };\n        this.importer = dat.importFiles(importPath, opts, () => {\n          console.log(`Finished importing files in ${importPath}`);\n          resolve(true);\n        });\n        this.importer.on('error', reject);\n        // Emit event that something has been imported into the dat\n        this.importer.on('put', src => this.emit('import', this, src.name.replace(this.directory, ''), src.stat));\n      } else {\n        resolve(false);\n      }\n    });\n  }\n\n  // Import a file or directory from another archive\n  async importFromDat(srcDatWrapper, fileOrDir, overwriteExisting = true) {\n    if (this.dat.writable) {\n      const dstPath = path.join(this.directory, fileOrDir);\n      return pda.exportArchiveToFilesystem({\n        srcArchive: srcDatWrapper.dat.archive,\n        dstPath,\n        srcPath: fileOrDir,\n        overwriteExisting,\n      });\n      // .then(() => this.importFiles());\n    }\n    console.log('Warning: You tried to write to a Dat that is not yours. Nothing has been written.');\n    // Fallback\n    return Promise.resolve(false);\n  }\n\n  // Lists the contents of the dat\n  listContents(below = '/') {\n    return pda.readdir(this.dat.archive, below, { recursive: true });\n  }\n\n  // Replays the history of this dat since a particular version.\n  replayHistory(sinceVersion = 0) {\n    const stream = this.dat.archive.history({ start: sinceVersion });\n    stream.on('data', data => this.emit('history data', this, data));\n    stream.on('end', () => this.emit('history end'));\n    return Promise.resolve(true);\n  }\n\n  // Pump the listed contents of the dat into some destination: func(datWriter, filePath)\n  pumpContents(below = '/') {\n    const stream = walker(below, { fs: this.dat.archive });\n    stream.on('data', data => this.emit('listing data', this, data.filepath, data));\n    // stream.on('data', data => func.call(context, this, data.filepath));\n    stream.on('end', () => this.emit('listing end', this));\n    /*\n    const handleEntry = through.ctor({ objectMode: true }, (data, enc, next) => {\n      func.call(context, this, data.filepath);\n      next();\n    });\n    // walker stream has an 'end' event\n    const pump = pumpify.obj(\n      walker(below, { fs: this.dat.archive }),\n      handleEntry(),\n    );\n    pump.on('end', () => {\n      console.log('DONE PUMPING!');\n    });\n    pump.on('error', () => {\n      console.log('ERROR!!!!!!');\n    });\n    */\n    return Promise.resolve(true);\n  }\n\n  // Download a file or directory\n  downloadContent(fn = '') {\n    const filename = `/${fn}/`;\n    console.log(`Downloading: ${filename}`);\n    console.log(this.stats.peers);\n    return pda.download(this.dat.archive, filename);\n  }\n\n  // Has the file been downloaded?\n  hasFile = file => new Promise(r => fs.access(path.join(this.directory, file), fs.F_OK, e => r(!e)))\n\n  // Rename\n  rename(dir, name) {\n    const renameAsync = Promise.promisify(fs.rename);\n    return renameAsync(this.directory, dir)\n      .then(() => {\n        this.directory = dir;\n        this.name = name;\n      });\n  }\n\n  // Initialize the collections\n  listFlattenedCollections() {\n    return this.collections.flatten();\n  }\n\n  // Write a manifest file\n  // @todo: fix me! why do i write empty manifests?\n  async writeManifest(opts = {}) {\n    const manifest = {\n      url: `dat://${this.key}`,\n      title: this.name,\n      ...opts,\n    };\n    await pda.writeManifest(this.dat.archive, manifest);\n    return this;\n  }\n\n  readManifest() {\n    return pda.readManifest(this.dat.archive);\n  }\n\n  updateManifest(manifest) {\n    return pda.updateManifest(this.dat.archive, manifest);\n  }\n\n  close() {\n    return new Promise((resolve, reject) => this.dat.close((err) => {\n      if (err) reject(err);\n      else resolve();\n    }));\n  }\n\n  exitHandler = options => (error) => {\n    if (options.cleanup) {\n      console.log('cleaning up!');\n      if (this.dat) this.dat.leave();\n      if (this.importer) this.importer.destroy();\n    }\n    if (error) console.log(error.stack);\n    if (options.exit) process.exit();\n  };\n\n}\n"]}