{"version":3,"sources":["../src/dat.js"],"names":["createDatAsync","promisify","renameAsync","rename","iteratePromised","co","fn","runner","v","next","done","resolve","value","then","DatWrapper","constructor","opts","connectionEventHandler","console","log","gray","bold","stats","peers","metadataDownloadEventHandler","index","data","metadataDownloadCount","header","Header","decode","type","warn","block","Node","progress","version","emit","key","file","path","downloadSpeed","network","uploadSpeed","total","metadataSyncEventHandler","metadataComplete","hasFile","r","access","join","directory","F_OK","e","existsSync","mkdirSync","name","latest","indexing","importer","availableCollections","create","dat","toString","archive","metadata","downloaded","run","importFiles","joinNetwork","trackStats","once","on","onEachMetadata","startingFrom","metadataIterator","start","imported","i","has","reject","get","error","result","node","isYours","writable","complete","importPath","putTotal","putCount","watch","count","dereference","files","src","replace","stat","importFromDat","srcDatWrapper","fileOrDir","overwriteExisting","dstPath","exportArchiveToFilesystem","srcArchive","srcPath","listContents","below","readdir","recursive","downloadContent","filename","download","dir","getAvailableCollections","list","catch","tap","colls","loadCollection","collection","flatten","informationAboutCollection","subcoll","info","title","description","s","writeManifest","manifest","url","readManifest","updateManifest","close","err"],"mappings":"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","file":"dat.js","sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport EventEmitter from 'events';\nimport createDat from 'dat-node';\nimport { openCollections, createCollection } from 'dat-collections';\n// import _ from 'lodash';\nimport Promise from 'bluebird';\nimport chalk from 'chalk';\nimport pda from 'pauls-dat-api/es5';\nimport messages from 'dat-protocol-buffers';\n// import prettysize from 'prettysize';\n\n// declare common promisified function here\n// so they will only be created once.\nconst createDatAsync = Promise.promisify(createDat);\nconst renameAsync = Promise.promisify(fs.rename);\n\nfunction iteratePromised(co, fn) {\n  const runner = () => {\n    const v = co.next();\n    if (v.done) return 'ok';\n    return Promise.resolve(v.value).then(fn).then(runner);\n  };\n  return runner();\n}\n\n// import { lsFilesPromised } from './utils/filesystem';\n\n// fork() - download a dat and fork it (thru dat.json)\n// list() - lists files\n// download() - downloads some files\n// read/writeManifest()\n// health/ stats\n\n/**\n * Adds Library-ish functions to a Dat. Expects the Dat's directory structure to\n * follow Calibre's (Author Name/ Publication Title/ Files)\n */\nexport default class DatWrapper extends EventEmitter {\n  constructor(opts) {\n    super();\n    this.directory = opts.directory;\n    this.metadataDownloadCount = 0;\n    this.metadataComplete = false;\n    // create if it doesn't exist\n    if (!fs.existsSync(opts.directory)) {\n      fs.mkdirSync(opts.directory);\n    }\n    this.key = opts.key;\n    this.name = opts.name;\n    this.stats = false;\n    this.opts = opts;\n    // Don't need the whole history (also we do need files as files)\n    this.opts.latest = true;\n    // If we're creating/ hosting a dat, set indexing to true\n    // this.opts.indexing = !this.key;\n    this.opts.indexing = true;\n    this.importer = false;\n    // Collections\n    this.availableCollections = false;\n  }\n\n  // Just creates a dat object\n  create() {\n    return createDatAsync(this.directory, this.opts)\n      .then((dat) => {\n        this.dat = dat;\n        this.key = dat.key.toString('hex');\n        this.metadataDownloadCount = dat.archive.metadata.downloaded();\n        this.metadataComplete = this.metadataDownloadCount === (this.version + 1);\n        console.log('created dat:', this.key);\n        console.log('metadata:', this.metadataDownloadCount, '/', this.version, this.metadataComplete);\n        return this;\n      });\n  }\n\n  // join network and import files\n  run() {\n    this.importFiles();\n\n    const network = this.dat.joinNetwork();\n    this.stats = this.dat.trackStats();\n    network.once('connection', this.connectionEventHandler);\n\n    // Watch for metadata syncing\n    const metadata = this.dat.archive.metadata;\n    metadata.on('download', this.metadataDownloadEventHandler);\n    metadata.on('sync', this.metadataSyncEventHandler);\n    return this;\n  }\n\n  connectionEventHandler = () => {\n    console.log('connects via network');\n    console.log(chalk.gray(chalk.bold('peers:')), this.stats.peers);\n  }\n\n  metadataDownloadEventHandler = (index, data) => {\n    this.metadataDownloadCount++;\n    if (index === 0) {\n      const header = messages.Header.decode(data);\n      if (header.type !== 'hyperdrive') console.warn('dat header is not a hyperdrive:', header.type);\n    } else {\n      const block = messages.Node.decode(data);\n      const progress = this.version > 0 ? (this.metadataDownloadCount / (this.version + 1)) * 100 : 0;\n      this.emit('download metadata', {\n        key: this.key,\n        version: index,\n        type: block.value ? 'put' : 'del',\n        progress,\n        file: block.path,\n        stats: block.value,\n        downloadSpeed: this.stats.network.downloadSpeed,\n        uploadSpeed: this.stats.network.uploadSpeed,\n        peers: this.stats.peers.total || 0,\n      });\n      // console.log(`downloaded ${index}/${dat.archive.version + 1}:`, block.path);\n      // console.log(`network: ${this.stats.peers.total || 0} peers (${prettysize(this.stats.network.downloadSpeed)}) ${progress.toFixed(2)}% complete`);\n    }\n  }\n\n  metadataSyncEventHandler = () => {\n    console.log('metadata synced');\n    this.metadataComplete = true;\n    this.emit('sync metadata', this.key);\n    // @todo: remove this next hack line.\n    // But for now we need it because on first load of dat we aren't getting the \"loaded\" event above\n    // this.emit('sync collections', this.key);\n  };\n\n  // call a function on each downloaded chuck of metadata.\n  onEachMetadata(fn, startingFrom) {\n    // returns a promise which will succeed if all are successful or fail and stop iterator.\n    return iteratePromised(this.metadataIterator(startingFrom), fn);\n  }\n\n  // this should iterate over only the downloaded metadata,\n  // we can use this to populate database before joining the swarm\n  // only importing what has already been downloaded, and then\n  // fetch the rest via the 'metadata' downloaded events.\n  * metadataIterator(start = 1) {\n    const metadata = this.dat.archive.metadata;\n    let imported = start - 1;\n    const total = metadata.downloaded();\n    // this can be improved by using the bitfield in hypercore to find next non 0 block, but will do for now.\n    for (let i = start; i <= this.version; i++) {\n      if (metadata.has(i)) {\n        yield new Promise((resolve, reject) => // fix this to not make functions in a loop.\n          metadata.get(i, (error, result) => {\n            if (error) reject(error);\n            else {\n              imported += 1;\n              const progress = total > 0 ? (imported / total) * 100 : 0;\n              const node = messages.Node.decode(result);\n              resolve({\n                version: i,\n                key: this.key,\n                progress,\n                type: node.value ? 'put' : 'del',\n                file: node.path,\n                stats: node.value,\n              });\n            }\n          }),\n        );\n      }\n    }\n  }\n\n  isYours() {\n    return this.dat.writable;\n  }\n\n  // How many peers for this dat\n  get peers() {\n    return this.stats.peers || { total: 0, complete: 0 };\n  }\n\n  get version() {\n    return this.dat.archive.version;\n  }\n\n  importFiles(importPath = this.directory) {\n    return new Promise((resolve, reject) => {\n      if (this.isYours()) {\n        console.log('Importing files under:', importPath);\n        let putTotal = 0;\n        let putCount = 0;\n        const opts = {\n          watch: true,\n          count: true,\n          dereference: true,\n          indexing: true,\n        };\n        this.importer = this.dat.importFiles(importPath, opts, () => {\n          console.log(`Finished importing files in ${importPath}`);\n          this.emit('imported', {\n            key: this.key,\n            path: importPath,\n          });\n          resolve(true);\n        });\n        this.importer.on('count', (count) => {\n          // file count is actually just a put count\n          // this could funk out on dat's with lots of dels.\n          putTotal = count.files;\n        });\n        this.importer.on('error', reject);\n        // Emit event that something has been imported into the dat\n        this.importer.on('put', (src) => {\n          putCount += 1;\n          const data = {\n            type: 'put',\n            key: this.key,\n            file: src.name.replace(this.directory, ''),\n            stat: src.stat,\n            progress: putTotal > 0 ? (putCount / putTotal) * 100 : 100,\n            version: this.version, // I am not sure if this works as version is not set by mirror-folder\n          };\n          this.emit('import', data);\n        });\n        this.importer.on('del', (src) => {\n          const data = {\n            type: 'del',\n            key: this.key,\n            file: src.name.replace(this.directory, ''),\n            stat: src.stat,\n            progress: putTotal > 0 ? (putCount / putTotal) * 100 : 100,\n            version: this.version,\n          };\n          this.emit('import', data);\n        });\n      } else {\n        resolve(false);\n      }\n    });\n  }\n\n  // Import a file or directory from another archive\n  async importFromDat(srcDatWrapper, fileOrDir, overwriteExisting = true) {\n    if (this.isYours()) {\n      const dstPath = path.join(this.directory, fileOrDir);\n      return pda.exportArchiveToFilesystem({\n        srcArchive: srcDatWrapper.dat.archive,\n        dstPath,\n        srcPath: fileOrDir,\n        overwriteExisting,\n      });\n      // .then(() => this.importFiles());\n    }\n    console.log('Warning: You tried to write to a Dat that is not yours. Nothing has been written.');\n    // Fallback\n    return Promise.resolve(false);\n  }\n\n  // Lists the contents of the dat\n  listContents(below = '/') {\n    return pda.readdir(this.dat.archive, below, { recursive: true });\n  }\n\n  // Download a file or directory\n  downloadContent(fn = '') {\n    const filename = `/${fn}/`;\n    console.log(`Downloading: ${filename}`);\n    console.log(this.stats.peers);\n    return pda.download(this.dat.archive, filename);\n  }\n\n  // Has the file been downloaded?\n  hasFile = file => new Promise(r => fs.access(path.join(this.directory, file), fs.F_OK, e => r(!e)))\n\n  // Rename\n  rename(dir, name) {\n    return renameAsync(this.directory, dir)\n      .then(() => {\n        this.directory = dir;\n        this.name = name;\n      });\n  }\n\n  // Returns a list of the collections available through this dat\n  getAvailableCollections() {\n    if (this.availableCollections) {\n      return this.availableCollections.list()\n      .catch(() => []);\n    }\n    return openCollections(this.dat.archive, 'dat-collections')\n    .tap((colls) => { this.availableCollections = colls; })\n    .then(colls => colls.list())\n    .catch(() => []);\n  }\n\n  // Loads a single collection and returns a list of its flattened contents\n  loadCollection(name) {\n    return createCollection(this.dat.archive, path.join('dat-collections', name))\n    .then(collection => collection.flatten())\n    .catch(() => []);\n  }\n\n  // Returns a {title, description} object for information about a collection.\n  // path is an array, potentially describing a subcollection\n  informationAboutCollection(name, subcoll) {\n    const info = { title: '', description: '' };\n    return createCollection(this.dat.archive, path.join('dat-collections', name))\n    .then(collection =>\n      collection.title(subcoll).then((s) => { info.title = s; })\n      .then(collection.description(subcoll).then((s) => { info.description = s; })))\n    .then(() => info)\n    .catch(() => info);\n  }\n\n  // Write a manifest file\n  // @todo: fix me! why do i write empty manifests?\n  async writeManifest(opts = {}) {\n    const manifest = {\n      url: `dat://${this.key}`,\n      title: this.name,\n      ...opts,\n    };\n    await pda.writeManifest(this.dat.archive, manifest);\n    return this;\n  }\n\n  readManifest() {\n    return pda.readManifest(this.dat.archive);\n  }\n\n  updateManifest(manifest) {\n    return pda.updateManifest(this.dat.archive, manifest);\n  }\n\n  close() {\n    return new Promise((resolve, reject) => this.dat.close((err) => {\n      if (err) reject(err);\n      else resolve();\n    }));\n  }\n}\n"]}