{"version":3,"sources":["../src/dat.js"],"names":["listDatContents","lsDat","readdirAsync","statAsync","dir","map","file","rFile","join","then","stat","isDirectory","dat","archive","promisify","readdir","context","each","f","console","log","DatWrapper","constructor","opts","exitHandler","options","error","cleanup","leave","stack","exit","process","directory","existsSync","mkdirSync","key","name","run","create","toString","network","joinNetwork","stats","trackStats","once","gray","bold","peers","createDatAsync","importFiles","resolve","reject","writable","importer","on","src","emit","listContents","results","downloadContent","fn","download"],"mappings":"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","file":"dat.js","sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport EventEmitter from 'events';\nimport createDat from 'dat-node';\n// import _ from 'lodash';\nimport Promise from 'bluebird';\nimport chalk from 'chalk';\nimport pda from 'pauls-dat-api';\nimport { flatten } from './utils/data';\n\n// Uses promises to recursively list a dat's contents using hyperdrive fs-ish functions\n// Note that the Promised hyperdrive functions are passed in by the caller.\nfunction lsDat(readdirAsync, statAsync, dir) {\n  return readdirAsync(dir).map((file) => {\n    const rFile = path.join(dir, file);\n    return statAsync(rFile).then((stat) => {\n      if (stat.isDirectory()) {\n        return lsDat(readdirAsync, statAsync, rFile);\n      }\n      return rFile;\n    });\n  });\n}\n\n// Lists the contents of a dat\nexport function listDatContents(dat) {\n  const archive = dat.archive;\n  // const archiveList = Promise.promisify(archive.list, { context: archive });\n  const readdirAsync = Promise.promisify(archive.readdir, { context: archive });\n  const statAsync = Promise.promisify(archive.stat, { context: archive });\n  lsDat(readdirAsync, statAsync, '/')\n    .each(f => console.log(f));\n  return [];\n  //return archiveList();\n}\n\n// export function listDatContents2(dat) {\n//   return pda.listFiles(dat.archive, '/');\n// }\n\n/**\n * Adds Library-ish functions to a Dat. Expects the Dat's directory structure to\n * follow Calibre's (Author Name/ Publication Title/ Files)\n */\nexport default class DatWrapper extends EventEmitter {\n  constructor(opts) {\n    super();\n    this.directory = opts.directory;\n    // create if it doesn't exist\n    if (!fs.existsSync(opts.directory)) {\n      fs.mkdirSync(opts.directory);\n    }\n    this.key = opts.key;\n    this.name = opts.name;\n    this.opts = opts;\n  }\n\n  // Creates a dat and grabs a key\n  // Perhaps this gets rewritten to be more like beaker:\n  // https://github.com/beakerbrowser/beaker/blob/2c2336430bdb00ea8e47e13fb2e8c8d5b89440ea/app/background-process/networks/dat/dat.js#L231\n  run() {\n    return this.create()\n      .then((dat) => {\n        this.dat = dat;\n        this.key = dat.key.toString('hex');\n        // const opts = {}; // various network options could go here (https://github.com/datproject/dat-node)\n        const network = dat.joinNetwork();\n        const stats = dat.trackStats();\n        /*\n        stats.once('update', () => {\n          console.log(chalk.gray(chalk.bold('stats updated')), stats.get());\n        });\n        */\n        network.once('connection', () => {\n          console.log('connects via network');\n          console.log(chalk.gray(chalk.bold('peers:')), stats.peers);\n        });\n        // this.start(dat);\n      })\n      .then(() => this);\n  }\n\n  // Just creates a dat object\n  create() {\n    const createDatAsync = Promise.promisify(createDat);\n    return createDatAsync(this.directory, this.opts);\n  }\n\n  importFiles() {\n    return new Promise((resolve, reject) => {\n      const dat = this.dat;\n      if (this.dat.writable) {\n        const importer = dat.importFiles({}, () => {\n          console.log(`Finished importing files in ${this.directory}`);\n          resolve(true);\n        });\n        importer.on('error', reject);\n        // Emit event that something has been imported into the dat\n        importer.on('put', src =>\n          this.emit('import', this, src.name, src.stat));\n      } else {\n        resolve(false);\n      }\n    });\n  }\n\n  // Lists the contents of the dat\n  listContents() {\n    const archive = this.dat.archive;\n    const readdirAsync = Promise.promisify(archive.readdir, { context: archive });\n    const statAsync = Promise.promisify(archive.stat, { context: archive });\n    return lsDat(readdirAsync, statAsync, '/')\n      .then(results => flatten(results));\n  }\n\n  // Download a file or directory\n  async downloadContent(fn = '') {\n    console.log(`Downloading: /${fn}`);\n    await pda.download(this.dat.archive, fn);\n  }\n\n  exitHandler = options => (error) => {\n    if (options.cleanup) {\n      console.log('cleaning up!');\n      if (this.dat) this.dat.leave();\n    }\n    if (error) console.log(error.stack);\n    if (options.exit) process.exit();\n  };\n\n}\n"]}