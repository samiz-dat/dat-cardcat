{"version":3,"sources":["../../src/utils/PromiseQueue.js"],"names":["PromiseQueue","constructor","cb","next","length","nextFn","queue","shift","wrap","fn","attempts","promise","callback","errored","err","console","error","resolve","Promise","e","reject","retryCount","retry","catch","then","args","add","opts","Error","priority","undefined","push","found","i","splice","unshift"],"mappings":"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","file":"PromiseQueue.js","sourcesContent":["class PromiseQueue {\n  constructor(cb) {\n    this.promise = null;\n    this.queue = [];\n    this.callback = cb;\n  }\n\n  next = () => {\n    if (this.length > 0) {\n      const nextFn = this.queue.shift();\n      return this.wrap(nextFn.fn, nextFn.cb, nextFn.attempts);\n    }\n    this.promise = null;\n    if (typeof this.callback === 'function') this.callback();\n    return true;\n  }\n\n  errored = (err) => {\n    console.error(err);\n    return err;\n  }\n\n  resolve(fn) {\n    try {\n      return Promise.resolve(fn());\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  wrap(fn, cb, attempts) {\n    let retryCount = 0;\n    const retry = (err) => {\n      retryCount += 1;\n      return (retryCount < attempts)\n        ? this.resolve(fn).catch(retry)\n        : this.errored(err);\n    };\n    return this.resolve(fn)\n      .catch(retry)\n      .then((...args) => {\n        // need a nice way of differentiating between failed calls and successfull\n        if (cb) cb(...args);\n      })\n      .then(this.next);\n  }\n\n  add(fn, cb, opts) {\n    if (typeof fn !== 'function') throw new Error('PromiseQueue.add() expects a function as an argument.');\n    if (!opts && typeof cb === 'object') {\n      return this.add(fn, null, cb);\n    }\n    const attempts = (opts && opts.attempts && opts.attempts > 0) ? opts.attempts : 1;\n    if (this.promise === null) {\n      this.promise = this.wrap(fn, cb, attempts);\n    } else {\n      // shift order based on priority\n      const next = {\n        fn,\n        attempts,\n        priority: (opts && opts.priority) ? opts.priority : 0,\n        cb: (typeof cb === 'function') ? cb : undefined,\n      };\n      if (!opts || !opts.priority) {\n        this.queue.push(next);\n      } else {\n        let found = false;\n        for (let i = this.length - 1; i >= 0; i--) {\n          if (this.queue[i].priority && this.queue[i].priority >= opts.priority) {\n            this.queue.splice(i + 1, 0, next);\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          this.queue.unshift(next);\n        }\n      }\n    }\n    return this;\n  }\n\n  get length() {\n    return this.queue.length;\n  }\n}\n\nexport default PromiseQueue;\n"]}