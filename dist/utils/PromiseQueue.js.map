{"version":3,"sources":["../../src/utils/PromiseQueue.js"],"names":["PromiseQueue","constructor","cb","PromiseFlavour","Promise","promise","queue","callback","promised","fn","resolve","e","reject","next","length","nextFn","shift","wrap","attempts","retryCount","retry","err","Error","catch","then","r","add","opts","priority","push","found","i","splice","unshift"],"mappings":"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","file":"PromiseQueue.js","sourcesContent":["\n\nclass PromiseQueue {\n  constructor(cb, PromiseFlavour) {\n    this.Promise = PromiseFlavour || Promise;\n    this.promise = null;\n    this.queue = [];\n    this.callback = cb;\n  }\n\n  promised(fn) {\n    try {\n      return this.Promise.resolve(fn());\n    } catch (e) {\n      return this.Promise.reject(e);\n    }\n  }\n\n  next() {\n    if (this.length > 0) {\n      const nextFn = this.queue.shift();\n      return this.wrap(nextFn.fn, nextFn.resolve, nextFn.reject, nextFn.attempts);\n    }\n    this.promise = null;\n    if (typeof this.callback === 'function') this.callback();\n    return true;\n  }\n\n  wrap(fn, resolve, reject, attempts) {\n    let retryCount = 0;\n    const retry = (err) => {\n      if (retryCount >= attempts) {\n        throw err || new Error('Unknown Error');\n      }\n      retryCount += 1;\n      return this.promised(fn).catch(retry);\n    };\n    return retry()\n      .then((r) => { resolve(r); }, (e) => { reject(e); })\n      .then(() => this.next());\n  }\n\n  add(fn, opts) {\n    if (typeof fn !== 'function') throw new Error('PromiseQueue.add() expects a function as an argument.');\n    return new this.Promise((resolve, reject) => {\n      const attempts = (opts && opts.attempts && opts.attempts > 0) ? opts.attempts : 1;\n      if (this.promise === null) {\n        this.promise = this.wrap(fn, resolve, reject, attempts);\n      } else {\n        // shift order based on priority\n        const next = {\n          fn,\n          attempts,\n          priority: (opts && opts.priority) ? opts.priority : 0,\n          resolve,\n          reject,\n        };\n        if (!opts || !opts.priority) {\n          this.queue.push(next);\n        } else {\n          let found = false;\n          for (let i = this.length - 1; i >= 0; i--) {\n            if (this.queue[i].priority && this.queue[i].priority >= opts.priority) {\n              this.queue.splice(i + 1, 0, next);\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            this.queue.unshift(next);\n          }\n        }\n      }\n    });\n  }\n\n  get length() {\n    return this.queue.length;\n  }\n}\n\nexport default PromiseQueue;\n"]}