{"version":3,"sources":["../../src/utils/PromiseQueue.js"],"names":["PromiseQueue","constructor","cb","next","length","nextFn","queue","shift","wrap","fn","attempts","promise","callback","errored","err","console","error","retryCount","retry","Promise","resolve","catch","then","add","a","Error","push"],"mappings":"2EAAA,MAAMA,YAAN,CAAmB;AACjBC,cAAYC,EAAZ,EAAgB;;;;;;AAMhBC,QANgB,GAMT,MAAM;AACX,UAAI,KAAKC,MAAL,GAAc,CAAlB,EAAqB;AACnB,cAAMC,SAAS,KAAKC,KAAL,CAAWC,KAAX,EAAf;AACA,eAAO,KAAKC,IAAL,CAAUH,OAAOI,EAAjB,EAAqBJ,OAAOK,QAA5B,CAAP;AACD;AACD,WAAKC,OAAL,GAAe,IAAf;AACA,UAAI,OAAO,KAAKC,QAAZ,KAAyB,UAA7B,EAAyC,KAAKA,QAAL;AACzC,aAAO,IAAP;AACD,KAde;;AAgBhBC,WAhBgB,GAgBLC,GAAD,IAAS;AACjBC,cAAQC,KAAR,CAAcF,GAAd;AACD,KAlBe,CACd,KAAKH,OAAL,GAAe,IAAf,CACA,KAAKL,KAAL,GAAa,EAAb,CACA,KAAKM,QAAL,GAAgBV,EAAhB,CACD;;AAgBDM,OAAKC,EAAL,EAASC,QAAT,EAAmB;AACjB,QAAIO,aAAa,CAAjB;AACA,UAAMC,QAASJ,GAAD,IAAS;AACrBG,oBAAc,CAAd;AACA,aAAQA,aAAaP,QAAd;AACHS,cAAQC,OAAR,CAAgBX,IAAhB,EAAsBY,KAAtB,CAA4BH,KAA5B,CADG;AAEH,WAAKL,OAAL,CAAaC,GAAb,CAFJ;AAGD,KALD;AAMA,WAAOK,QAAQC,OAAR,CAAgBX,IAAhB;AACJY,SADI,CACEH,KADF;AAEJI,QAFI,CAEC,KAAKnB,IAFN,CAAP;AAGD;;AAEDoB,MAAId,EAAJ,EAAQC,QAAR,EAAkB;AAChB,UAAMc,IAAKd,YAAYA,WAAW,CAAxB,GAA6BA,QAA7B,GAAwC,CAAlD;AACA,QAAI,OAAOD,EAAP,KAAc,UAAlB,EAA8B,MAAM,IAAIgB,KAAJ,CAAU,uDAAV,CAAN;AAC9B,QAAI,KAAKd,OAAL,KAAiB,IAArB,EAA2B;AACzB,WAAKA,OAAL,GAAe,KAAKH,IAAL,CAAUC,EAAV,EAAce,CAAd,CAAf;AACD,KAFD,MAEO;AACL,WAAKlB,KAAL,CAAWoB,IAAX,CAAgB,EAAEjB,EAAF,EAAMC,UAAUc,CAAhB,EAAhB;AACD;AACF;;AAED,MAAIpB,MAAJ,GAAa;AACX,WAAO,KAAKE,KAAL,CAAWF,MAAlB;AACD,GA9CgB,C;;;AAiDJJ,Y","file":"PromiseQueue.js","sourcesContent":["class PromiseQueue {\n  constructor(cb) {\n    this.promise = null;\n    this.queue = [];\n    this.callback = cb;\n  }\n\n  next = () => {\n    if (this.length > 0) {\n      const nextFn = this.queue.shift();\n      return this.wrap(nextFn.fn, nextFn.attempts);\n    }\n    this.promise = null;\n    if (typeof this.callback === 'function') this.callback();\n    return true;\n  }\n\n  errored = (err) => {\n    console.error(err);\n  }\n\n  wrap(fn, attempts) {\n    let retryCount = 0;\n    const retry = (err) => {\n      retryCount += 1;\n      return (retryCount < attempts)\n        ? Promise.resolve(fn()).catch(retry)\n        : this.errored(err);\n    };\n    return Promise.resolve(fn())\n      .catch(retry)\n      .then(this.next);\n  }\n\n  add(fn, attempts) {\n    const a = (attempts && attempts > 0) ? attempts : 1;\n    if (typeof fn !== 'function') throw new Error('PromiseQueue.add() expects a function as an argument.');\n    if (this.promise === null) {\n      this.promise = this.wrap(fn, a);\n    } else {\n      this.queue.push({ fn, attempts: a });\n    }\n  }\n\n  get length() {\n    return this.queue.length;\n  }\n}\n\nexport default PromiseQueue;\n"]}