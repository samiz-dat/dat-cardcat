{"version":3,"sources":["../src/multidat.js"],"names":["Multidat","constructor","baseDir","dats","init","discoverDats","initOthers","lookFor","map","dat","filter","existsSync","dir","startsWith","key","keys","each","importDir","name","then","console","log","bold","opts","createIfMissing","sparse","importDat","directory","split","sep","slice","importRemoteDat","forkDat","deleteAfterFork","forkDir","format","base","dw","exportArchiveToFilesystem","srcArchive","archive","dstPath","writeManifest","manifest","getDat","forkOf","resolve","newDat","run","catch","err","getDats","Object","reject","pathToDat","removeDat","downloadFromDat","fileOrDir","downloadContent","datHasFile","file","hasFile","copyFromDatToDat","keyFrom","keyTo","join","dwFrom","dwTo","importFromDat"],"mappings":"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","file":"multidat.js","sourcesContent":["import path from 'path';\nimport fs from 'fs';\nimport Promise from 'bluebird';\nimport chalk from 'chalk';\nimport pda from 'pauls-dat-api';\n\nimport DatWrapper from './dat'; // this function can be made a method of dat class too.\nimport Database from './db'; // eslint-disable-line\n\nimport { getDirectories } from './utils/filesystem';\n\n/**\n  The Multidat class manages the loading and handling of dats, both remote and local.\n */\n\n// Class definition\nexport default class Multidat {\n  constructor(baseDir) {\n    // The base directory where remote dats will be kept\n    this.baseDir = baseDir;\n    // the registry of loaded dats\n    this.dats = [];\n  }\n\n  // On initialization, look for already existing dats to pre-load in the baseDir\n  init() {\n    return this.discoverDats();\n  }\n\n  // ... but there might be an additional list of dats elsewhere to look for:\n  // [{ dat: <key>, dir: <path>, name: <str>}, ]\n  initOthers(lookFor = []) {\n    return Promise.map(lookFor, dat => dat)\n      .filter(dat => fs.existsSync(dat.dir)) //\n      .filter(dat => !dat.dir.startsWith(this.baseDir)) // not in data directory\n      .filter(dat => !(dat.key in this.dats.keys())) // not in registry\n      .each(dat => this.importDir(dat.dir, dat.name))\n      .then(() => this.dats);\n  }\n\n  // Look inside the base directory for any directories that seem to be dats\n  discoverDats() {\n    return getDirectories(this.baseDir)\n      .map((name) => {\n        console.log(`Attempting to load dir: ${chalk.bold(name)} as a dat`);\n        const opts = {\n          name,\n          createIfMissing: false, // @todo: this was false before, but threw error. find out why?\n          sparse: true,\n        };\n        return this.importDat(opts);\n      })\n      .then(() => this);\n  }\n\n  // Imports a directory on the local filesystem as a dat.\n  // This should not be called on any directories inside `dataDir`, which are loaded differently\n  importDir(directory, name = false) {\n    console.log(`Attempting to import local directory: ${directory}`);\n    const opts = {\n      directory,\n      name: name || directory.split(path.sep).slice(-1)[0],\n    };\n    return this.importDat(opts);\n  }\n\n  // Importing a remote dat by its key\n  importRemoteDat(key, name = false) {\n    console.log(`Attempting to import remote dat: ${key}`);\n    const opts = {\n      key,\n      name: name || key,\n      sparse: true,\n    };\n    return this.importDat(opts);\n  }\n\n  // Create a new dat by forking an existing Dat\n  forkDat(key, name = false, dir = false) {\n    const deleteAfterFork = !(key in this.dats);\n    const forkDir = (!dir)\n      ? path.format({\n        dir: this.baseDir,\n        base: name || `${key} (forked)`,\n      })\n      : dir;\n    console.log(`Attempting to fork dat: ${key} into ${forkDir}`);\n    if (deleteAfterFork) {\n      return this.importRemoteDat(key)\n        .then(dw => pda.exportArchiveToFilesystem({\n          srcArchive: dw.dat.archive,\n          dstPath: forkDir,\n        }))\n        .then(() => this.importDir(forkDir, name))\n        .then(dw => dw.writeManifest(manifest));\n    }\n    return this.getDat(key)\n      .then(dw => pda.exportArchiveToFilesystem({\n        srcArchive: dw.dat.archive,\n        dstPath: forkDir,\n      }))\n      .then(() => this.importDir(forkDir, name))\n      .then(dw => dw.writeManifest({ forkOf: key }))\n      .then(dw => dw);\n  }\n\n  // Does the work of importing a functional dat into the catalog\n  importDat(opts) {\n    if ('key' in opts && opts.key in this.dats) {\n      // The dat is already loaded, we shouldn't reimport it\n      console.log(`You are trying to import a dat that is already loaded: ${opts.key}`);\n      return Promise.resolve(false);\n    }\n    if (!opts.directory) {\n      opts.directory = path.format({\n        dir: this.baseDir,\n        base: (opts.name) ? opts.name : opts.key,\n      });\n    }\n    const newDat = new DatWrapper(opts, this);\n    // dw.on('download', (...args) => this.handleDatDownloadEvent(...args));\n    return newDat.run()\n      .then(() => {\n        this.dats[newDat.key] = newDat;\n        return newDat;\n      })\n      .catch((err) => {\n        console.log(`* Something went wrong when importing ${opts.directory}`);\n        console.log(err);\n      });\n  }\n\n  // Get the list of dats in this multidat as a Promise\n  getDats() {\n    return Promise.map(Object.keys(this.dats), key => this.getDat(key));\n  }\n\n  // Get a dat as a Promise\n  getDat(key) {\n    return new Promise((resolve, reject) => {\n      if (key in this.dats) {\n        resolve(this.dats[key]);\n      } else {\n        reject(false);\n      }\n    });\n  }\n\n  // Get a path to a dat\n  pathToDat(key) {\n    return new Promise((resolve, reject) => {\n      if (key in this.dats) {\n        resolve(this.dats[key].directory);\n      } else {\n        reject(false);\n      }\n    });\n  }\n\n  // Remove a dat from the multidat\n  removeDat(key) {\n    return new Promise((resolve) => {\n      if (key in this.dats) {\n        delete this.dats[key];\n      } else {\n        resolve(false);\n      }\n    });\n  }\n\n  // Download a file or directory from a dat\n  downloadFromDat(key, fileOrDir) {\n    return this.getDat(key)\n      .then(dw => dw.downloadContent(fileOrDir));\n  }\n\n  // Does a dat have a file?\n  datHasFile(key, file) {\n    return this.getDat(key)\n      .then(dw => dw.hasFile(file));\n  }\n\n  // Copy a file or directory from one dat to another\n  copyFromDatToDat(keyFrom, keyTo, fileOrDir) {\n    return Promise.join(\n      this.getDat(keyFrom),\n      this.getDat(keyTo),\n      (dwFrom, dwTo) => dwTo.importFromDat(dwFrom, fileOrDir),\n    );\n  }\n}\n"]}