{"version":3,"sources":["../src/multidat.js"],"names":["rimrafAsync","promisify","Multidat","constructor","baseDir","dats","init","discoverDats","close","all","getDats","map","dw","initOthers","lookFor","dat","filter","existsSync","dir","startsWith","key","each","importDir","name","then","console","log","bold","opts","createIfMissing","sparse","importDat","directory","split","sep","slice","importRemoteDat","forkDat","deleteAfterFork","forkDir","format","base","exportArchiveToFilesystem","srcArchive","archive","dstPath","writeManifest","forkOf","finally","deleteDat","getDat","d","reject","Error","newDat","create","catch","err","values","undefined","pathToDat","removeDat","resolve","downloadFromDat","fileOrDir","downloadContent","datHasFile","file","hasFile","copyFromDatToDat","keyFrom","keyTo","from","to","importFromDat"],"mappings":"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","file":"multidat.js","sourcesContent":["import path from 'path';\nimport fs from 'fs';\nimport Promise from 'bluebird';\nimport chalk from 'chalk';\nimport rimraf from 'rimraf';\nimport pda from 'pauls-dat-api/es5';\nimport _ from 'lodash';\nimport DatWrapper from './dat'; // this function can be made a method of dat class too.\nimport Database from './db'; // eslint-disable-line\n\nimport { getDirectories } from './utils/filesystem';\n\nconst rimrafAsync = Promise.promisify(rimraf);\n\n/**\n  The Multidat class manages the loading and handling of dats, both remote and local.\n */\n\n// Class definition\nexport default class Multidat {\n  constructor(baseDir) {\n    // The base directory where remote dats will be kept\n    this.baseDir = baseDir;\n    // the registry of loaded dats\n    this.dats = {};\n  }\n\n  // On initialization, look for already existing dats to pre-load in the baseDir\n  init() {\n    return this.discoverDats();\n  }\n\n  close() {\n    return Promise.all(this.getDats().map(dw => dw.close()));\n  }\n\n  // ... but there might be an additional list of dats elsewhere to look for:\n  // [{ dat: <key>, dir: <path>, name: <str>}, ]\n  initOthers(lookFor = []) {\n    return Promise.map(lookFor, dat => dat)\n      .filter(dat => fs.existsSync(dat.dir)) //\n      .filter(dat => !dat.dir.startsWith(this.baseDir)) // not in data directory\n      .filter(dat => !this.dats[dat.key]) // not in registry\n      .each(dat => this.importDir(dat.dir, dat.name))\n      .then(() => this.dats);\n  }\n\n  // Look inside the base directory for any directories that seem to be dats\n  discoverDats() {\n    return getDirectories(this.baseDir)\n      .map((name) => {\n        console.log(`Attempting to load dir: ${chalk.bold(name)} as a dat`);\n        const opts = {\n          name,\n          createIfMissing: false, // @todo: this was false before, but threw error. find out why?\n          sparse: true,\n        };\n        return this.importDat(opts);\n      })\n      .then(() => this);\n  }\n\n  // Imports a directory on the local filesystem as a dat.\n  // This should not be called on any directories inside `dataDir`, which are loaded differently\n  importDir(directory, name = false) {\n    console.log(`Attempting to import local directory: ${directory}`);\n    const opts = {\n      directory,\n      name: name || directory.split(path.sep).slice(-1)[0],\n    };\n    return this.importDat(opts);\n  }\n\n  // Importing a remote dat by its key\n  importRemoteDat(key, name = false) {\n    console.log(`Attempting to import remote dat: ${key}`);\n    const opts = {\n      key,\n      name: name || key,\n      sparse: true,\n    };\n    return this.importDat(opts);\n  }\n\n  // Create a new dat by forking an existing Dat\n  forkDat(key, name = false, dir = false) {\n    const deleteAfterFork = !this.dats[key];\n    const forkDir = (!dir)\n      ? path.format({\n        dir: this.baseDir,\n        base: name || `${key} (forked)`,\n      })\n      : dir;\n    console.log(`Attempting to fork dat: ${key} into ${forkDir}`);\n    if (deleteAfterFork) {\n      return this.importRemoteDat(key)\n        .then(dw => pda.exportArchiveToFilesystem({\n          srcArchive: dw.dat.archive,\n          dstPath: forkDir,\n        }))\n        .then(() => this.importDir(forkDir, name))\n        .then(dw => dw.writeManifest({ forkOf: key }))\n        .finally(() => this.deleteDat(key));\n    }\n    const dw = this.getDat(key);\n    return pda.exportArchiveToFilesystem({\n      srcArchive: dw.dat.archive,\n      dstPath: forkDir,\n    })\n    .then(() => this.importDir(forkDir, name))\n    .then(d => d.writeManifest({ forkOf: key }));\n  }\n\n  // Does the work of importing a functional dat into the catalog\n  importDat(opts) {\n    if (opts.key && this.dats[opts.key]) {\n      // The dat is already loaded, we shouldn't reimport it\n      console.log(`You are trying to import a dat that is already loaded: ${opts.key}`);\n      return Promise.reject(new Error('duplicate'));\n    }\n    if (!opts.directory) {\n      opts.directory = path.format({\n        dir: this.baseDir,\n        base: (opts.name) ? opts.name : opts.key,\n      });\n    }\n    const newDat = new DatWrapper(opts, this);\n    // dw.on('download', (...args) => this.handleDatDownloadEvent(...args));\n    return newDat.create()\n      .then(() => {\n        this.dats[newDat.key] = newDat;\n        return newDat;\n      })\n      .catch((err) => {\n        console.log(`* Something went wrong when importing ${opts.directory}`);\n        console.log(err);\n      });\n  }\n\n  // return array of dats\n  getDats() {\n    return _.values(this.dats);\n  }\n\n  getDat(key) {\n    const dat = this.dats[key];\n    return (dat !== undefined) ? dat : null;\n  }\n\n  // Get a path to a dat\n  pathToDat(key) {\n    const dat = this.getDat(key);\n    return dat ? dat.directory : null;\n  }\n\n  // Remove a dat from the multidat\n  removeDat(key) {\n    const dat = this.dats[key];\n    if (dat !== undefined) {\n      return Promise.resolve(false);\n    }\n    return dat.close()\n      .then(() => {\n        delete this.dats[key];\n        return true;\n      });\n  }\n\n  // Remove a dat from the multidat and delete it from the filesystem\n  deleteDat(key) {\n    return this.getDat(key)\n      .then(dw => rimrafAsync(dw.directory))\n      .finally(() => this.removeDat(key));\n  }\n\n  // Download a file or directory from a dat\n  downloadFromDat(key, fileOrDir) {\n    const dat = this.getDat(key);\n    return dat.downloadContent(fileOrDir);\n  }\n\n  // Does a dat have a file?\n  datHasFile(key, file) {\n    const dat = this.getDat(key);\n    return dat.hasFile(file);\n  }\n\n  // Copy a file or directory from one dat to another\n  copyFromDatToDat(keyFrom, keyTo, fileOrDir) {\n    const from = this.getDat(keyFrom);\n    const to = this.getDat(keyTo);\n    return to.importFromDat(from, fileOrDir);\n  }\n}\n"]}