{"version":3,"sources":["../src/multidat.js"],"names":["Multidat","constructor","baseDir","dats","init","discoverDats","initOthers","lookFor","map","dat","filter","existsSync","dir","startsWith","key","keys","each","importDir","name","then","console","log","bold","opts","createIfMissing","sparse","importDat","directory","split","sep","slice","importRemoteDat","resolve","format","base","newDat","run","catch","err","getDats","Object","getDat","reject","pathToDat","removeDat","downloadFromDat","fileOrDir","dw","downloadContent","datHasFile","file","hasFile"],"mappings":"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","file":"multidat.js","sourcesContent":["import path from 'path';\nimport fs from 'fs';\nimport Promise from 'bluebird';\nimport chalk from 'chalk';\nimport _ from 'lodash';\nimport rimraf from 'rimraf';\nimport config from './config';\n\nimport DatWrapper from './dat'; // this function can be made a method of dat class too.\nimport Database from './db'; // eslint-disable-line\n\nimport { getDirectories, notADir } from './utils/filesystem';\nimport parseEntry from './utils/importers';\n\n/**\n  The Multidat class manages the loading and handling of dats, both remote and local.\n */\n\n// Class definition\nexport class Multidat {\n  constructor(baseDir) {\n    // The base directory where remote dats will be kept\n    this.baseDir = baseDir;\n    // the registry of loaded dats\n    this.dats = [];\n  }\n\n  // On initialization, look for already existing dats to pre-load in the baseDir\n  init() {\n    return this.discoverDats();\n  }\n\n  // ... but there might be an additional list of dats elsewhere to look for:\n  // [{ dat: <key>, dir: <path>, name: <str>}, ]\n  initOthers(lookFor = []) {\n    return Promise.map(lookFor, dat => dat)\n      .filter(dat => fs.existsSync(dat.dir)) //\n      .filter(dat => !dat.dir.startsWith(this.baseDir)) // not in data directory\n      .filter(dat => !(dat.key in this.dats.keys())) // not in registry\n      .each(dat => this.importDir(dat.dir, dat.name))\n      .then(() => this.dats);\n  }\n\n  // Look inside the base directory for any directories that seem to be dats\n  discoverDats() {\n    console.log(this.baseDir);\n    return getDirectories(this.baseDir)\n      .map((name) => {\n        console.log(`Attempting to load dir: ${chalk.bold(name)} as a dat`);\n        const opts = {\n          name,\n          createIfMissing: false, // @todo: this was false before, but threw error. find out why?\n          sparse: true,\n        };\n        return this.importDat(opts);\n      })\n      .then(() => this);\n  }\n\n  // Imports a directory on the local filesystem as a dat.\n  // This should not be called on any directories inside `dataDir`, which are loaded differently\n  importDir(directory, name = false) {\n    console.log(`Attempting to import local directory: ${directory}`);\n    const opts = {\n      directory,\n      name: name || directory.split(path.sep).slice(-1)[0],\n    };\n    return this.importDat(opts);\n  }\n\n  // Importing a remote dat by its key\n  importRemoteDat(key, name = false) {\n    console.log(`Attempting to import remote dat: ${key}`);\n    const opts = {\n      key,\n      name: name || key,\n      sparse: true,\n    };\n    return this.importDat(opts);\n  }\n\n  // Does the work of importing a functional dat into the catalog\n  importDat(opts) {\n    if ('key' in opts && opts.key in this.dats) {\n      // The dat is already loaded, we shouldn't reimport it\n      console.log(`You are trying to import a dat that is already loaded: ${opts.key}`);\n      return Promise.resolve(false);\n    }\n    if (!opts.directory) {\n      opts.directory = path.format({\n        dir: this.baseDir,\n        base: (opts.name) ? opts.name : opts.key,\n      });\n    }\n    const newDat = new DatWrapper(opts, this);\n    // dw.on('download', (...args) => this.handleDatDownloadEvent(...args));\n    return newDat.run()\n      .then(() => {\n        this.dats[newDat.key] = newDat;\n        return newDat;\n      })\n      .catch((err) => {\n        console.log(`* Something went wrong when importing ${opts.directory}`);\n        console.log(err);\n      });\n  }\n\n  getDats() {\n    return Promise.map(Object.keys(this.dats), key => this.getDat(key));\n  }\n\n  getDat(key) {\n    return new Promise((resolve, reject) => {\n      if (key in this.dats) {\n        resolve(this.dats[key]);\n      } else {\n        reject(false);\n      }\n    });\n  }\n\n  pathToDat(key) {\n    return new Promise((resolve, reject) => {\n      if (key in this.dats) {\n        resolve(this.dats[key].directory);\n      } else {\n        reject(false);\n      }\n    });\n  }\n\n  removeDat(key) {\n    return new Promise((resolve, reject) => {\n      if (key in this.dats) {\n        delete this.dats[key];\n      } else {\n        reject(false);\n      }\n    });\n  }\n\n  downloadFromDat(key, fileOrDir) {\n    return this.getDat(key)\n      .then(dw => dw.downloadContent(fileOrDir));\n  }\n\n  datHasFile(key, file) {\n    return this.getDat(key)\n      .then(dw => dw.hasFile(file));\n  }\n}\n\nexport default Multidat;\n"]}