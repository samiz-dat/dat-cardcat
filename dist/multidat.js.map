{"version":3,"sources":["../src/multidat.js"],"names":["Multidat","constructor","baseDir","dats","init","discoverDats","initOthers","lookFor","map","dat","filter","existsSync","dir","startsWith","key","keys","each","importDir","name","then","console","log","bold","opts","createIfMissing","sparse","importDat","directory","split","sep","slice","importRemoteDat","forkDat","deleteAfterFork","forkDir","format","base","dw","exportArchiveToFilesystem","srcArchive","archive","dstPath","writeManifest","forkOf","finally","deleteDat","getDat","d","resolve","newDat","run","catch","err","getDats","values","undefined","pathToDat","removeDat","close","rimrafAsync","promisify","downloadFromDat","fileOrDir","downloadContent","datHasFile","file","hasFile","copyFromDatToDat","keyFrom","keyTo","from","to","importFromDat"],"mappings":"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","file":"multidat.js","sourcesContent":["import path from 'path';\nimport fs from 'fs';\nimport Promise from 'bluebird';\nimport chalk from 'chalk';\nimport rimraf from 'rimraf';\nimport pda from 'pauls-dat-api';\nimport _ from 'lodash';\nimport DatWrapper from './dat'; // this function can be made a method of dat class too.\nimport Database from './db'; // eslint-disable-line\n\nimport { getDirectories } from './utils/filesystem';\n\n/**\n  The Multidat class manages the loading and handling of dats, both remote and local.\n */\n\n// Class definition\nexport default class Multidat {\n  constructor(baseDir) {\n    // The base directory where remote dats will be kept\n    this.baseDir = baseDir;\n    // the registry of loaded dats\n    this.dats = [];\n  }\n\n  // On initialization, look for already existing dats to pre-load in the baseDir\n  init() {\n    return this.discoverDats();\n  }\n\n  // ... but there might be an additional list of dats elsewhere to look for:\n  // [{ dat: <key>, dir: <path>, name: <str>}, ]\n  initOthers(lookFor = []) {\n    return Promise.map(lookFor, dat => dat)\n      .filter(dat => fs.existsSync(dat.dir)) //\n      .filter(dat => !dat.dir.startsWith(this.baseDir)) // not in data directory\n      .filter(dat => !(dat.key in this.dats.keys())) // not in registry\n      .each(dat => this.importDir(dat.dir, dat.name))\n      .then(() => this.dats);\n  }\n\n  // Look inside the base directory for any directories that seem to be dats\n  discoverDats() {\n    return getDirectories(this.baseDir)\n      .map((name) => {\n        console.log(`Attempting to load dir: ${chalk.bold(name)} as a dat`);\n        const opts = {\n          name,\n          createIfMissing: false, // @todo: this was false before, but threw error. find out why?\n          sparse: true,\n        };\n        return this.importDat(opts);\n      })\n      .then(() => this);\n  }\n\n  // Imports a directory on the local filesystem as a dat.\n  // This should not be called on any directories inside `dataDir`, which are loaded differently\n  importDir(directory, name = false) {\n    console.log(`Attempting to import local directory: ${directory}`);\n    const opts = {\n      directory,\n      name: name || directory.split(path.sep).slice(-1)[0],\n    };\n    return this.importDat(opts);\n  }\n\n  // Importing a remote dat by its key\n  importRemoteDat(key, name = false) {\n    console.log(`Attempting to import remote dat: ${key}`);\n    const opts = {\n      key,\n      name: name || key,\n      sparse: true,\n    };\n    return this.importDat(opts);\n  }\n\n  // Create a new dat by forking an existing Dat\n  forkDat(key, name = false, dir = false) {\n    const deleteAfterFork = !(key in this.dats);\n    const forkDir = (!dir)\n      ? path.format({\n        dir: this.baseDir,\n        base: name || `${key} (forked)`,\n      })\n      : dir;\n    console.log(`Attempting to fork dat: ${key} into ${forkDir}`);\n    if (deleteAfterFork) {\n      return this.importRemoteDat(key)\n        .then(dw => pda.exportArchiveToFilesystem({\n          srcArchive: dw.dat.archive,\n          dstPath: forkDir,\n        }))\n        .then(() => this.importDir(forkDir, name))\n        .then(dw => dw.writeManifest({ forkOf: key }))\n        .finally(() => this.deleteDat(key));\n    }\n    const dw = this.getDat(key);\n    return pda.exportArchiveToFilesystem({\n      srcArchive: dw.dat.archive,\n      dstPath: forkDir,\n    })\n    .then(() => this.importDir(forkDir, name))\n    .then(d => d.writeManifest({ forkOf: key }));\n  }\n\n  // Does the work of importing a functional dat into the catalog\n  importDat(opts) {\n    if ('key' in opts && opts.key in this.dats) {\n      // The dat is already loaded, we shouldn't reimport it\n      console.log(`You are trying to import a dat that is already loaded: ${opts.key}`);\n      return Promise.resolve(false);\n    }\n    if (!opts.directory) {\n      opts.directory = path.format({\n        dir: this.baseDir,\n        base: (opts.name) ? opts.name : opts.key,\n      });\n    }\n    const newDat = new DatWrapper(opts, this);\n    // dw.on('download', (...args) => this.handleDatDownloadEvent(...args));\n    return newDat.run()\n      .then(() => {\n        this.dats[newDat.key] = newDat;\n        return newDat;\n      })\n      .catch((err) => {\n        console.log(`* Something went wrong when importing ${opts.directory}`);\n        console.log(err);\n      });\n  }\n\n  // return array of dats\n  getDats() {\n    return _.values(this.dats);\n  }\n\n  getDat(key) {\n    const dat = this.dats[key];\n    return (dat !== undefined) ? dat : null;\n  }\n\n  // Get a path to a dat\n  pathToDat(key) {\n    const dat = this.getDat(key);\n    return dat ? dat.directory : null;\n  }\n\n  // Remove a dat from the multidat\n  removeDat(key) {\n    const dat = this.dats[key];\n    if (dat !== undefined) {\n      return Promise.resolve(false);\n    }\n    return dat.close()\n      .then(() => {\n        delete this.dats[key];\n        return true;\n      });\n  }\n\n  // Remove a dat from the multidat and delete it from the filesystem\n  deleteDat(key) {\n    const rimrafAsync = Promise.promisify(rimraf);\n    return this.getDat(key)\n      .then(dw => rimrafAsync(dw.directory))\n      .finally(() => this.removeDat(key));\n  }\n\n  // Download a file or directory from a dat\n  downloadFromDat(key, fileOrDir) {\n    const dat = this.getDat(key);\n    return dat.downloadContent(fileOrDir);\n  }\n\n  // Does a dat have a file?\n  datHasFile(key, file) {\n    const dat = this.getDat(key);\n    return dat.hasFile(file);\n  }\n\n  // Copy a file or directory from one dat to another\n  copyFromDatToDat(keyFrom, keyTo, fileOrDir) {\n    const from = this.getDat(keyFrom);\n    const to = this.getDat(keyTo);\n    return to.importFromDat(from, fileOrDir);\n  }\n}\n"]}